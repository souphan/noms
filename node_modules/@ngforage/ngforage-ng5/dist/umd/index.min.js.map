{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///index.min.js","webpack:///webpack/bootstrap 7ab7d4a5f88fe9838b1c","webpack:///external \"tslib\"","webpack:///external {\"root\":[\"ng\",\"core\"],\"commonjs\":\"@angular/core\",\"commonjs2\":\"@angular/core\",\"amd\":\"@angular/core\"}","webpack:///./src/NgForage/util/addToStringTag.ts","webpack:///./src/NgForage/main/NgForage.service.ts","webpack:///./node_modules/localforage/dist/localforage.js","webpack:///./src/NgForage/config/NgForageConfig.service.ts","webpack:///./src/NgForage/cache/NgForageCache.service.ts","webpack:///./src/NgForage/config/BaseConfigurableImpl.service.ts","webpack:///./src/NgForage/instance-factory/InstanceFactory.service.ts","webpack:///./src/NgForage/NgForage.module.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/NgForage/cache/CachedItemImpl.ts","webpack:///./node_modules/typescript-lazy-get-decorator/dist/esm5/LazyGetter.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","addToStringTag","Symbol","target","tag","NgForage","__WEBPACK_IMPORTED_MODULE_0_tslib__","__WEBPACK_IMPORTED_MODULE_1__angular_core__","__WEBPACK_IMPORTED_MODULE_2__config_BaseConfigurableImpl_service__","__WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__","_super","apply","arguments","store","driver","clear","getItem","key","iterate","iteratee","index","keys","length","ready","removeItem","setItem","data","supports","global","f","e","t","r","u","a","Error","code","1","_dereq_","nextTick","draining","oldQueue","len","queue","immediate","task","push","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","document","createTextNode","observe","characterData","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","window","2","INTERNAL","Promise","resolver","TypeError","state","PENDING","outcome","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","value","returnValue","handlers","reject","resolve","getThen","obj","then","thenable","onError","onSuccess","tryToUnwrap","result","tryCatch","status","out","reason","all","iterable","toString","values","Array","resolved","resolveFromAll","outValue","error","race","response","REJECTED","FULFILLED","constructor","3","4","_classCallCheck","instance","Constructor","createBlob","parts","properties","Blob","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","type","executeCallback","callback","executeTwoCallbacks","errorCallback","normalizeKey","console","warn","String","_binStringToArrayBuffer","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","_checkBlobSupportWithoutCaching","idb","Promise$1","txn","transaction","DETECT_BLOB_SUPPORT_STORE","READ_WRITE","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","navigator","userAgent","match","matchedEdge","parseInt","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_rejectReadiness","err","_getConnection","upgradeNeeded","db","close","dbArgs","version","openreq","open","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","newVersion","onerror","onsuccess","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","base64","btoa","__local_forage_encoded_blob","readAsBinaryString","_decodeBlob","encodedBlob","atob","_isEncodedBlob","_fullyReady","_initReady","_dbInfo","_tryReconnect","forages","j","createTransaction","mode","tx","_initStorage","options","ignoreErrors","initPromises","forage","slice","_defaultConfig","k","READ_ONLY","req","undefined","iterator","openCursor","iterationNumber","cursor","blobSupport","count","advanced","advance","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","buffer","bytes","BASE_CHARS","indexOf","bufferToString","base64String","substring","serialize","valueType","toString$1","marker","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","onload","str","BLOB_TYPE_PREFIX","TYPE_BLOB","readAsArrayBuffer","JSON","stringify","deserialize","SERIALIZED_MARKER_LENGTH","parse","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","test","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_initStorage$1","dbInfoPromise","openDatabase","description","size","executeSql","serializer","localforageSerializer","getItem$1","results","rows","item","iterate$1","_setItem","retriesLeft","originalValue","sqlError","QUOTA_ERR","setItem$1","removeItem$1","clear$1","length$1","key$1","keys$1","checkIfLocalStorageThrows","localStorage","_isLocalStorageUsable","_initStorage$2","keyPrefix","clear$2","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","itemKey","length$2","removeItem$2","setItem$2","callWhenReady","localForageInstance","libraryMethod","_args","extend","arg","_key","isArray","_typeof","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","asyncStorage","_driver","_support","isSafari","platform","hasFetch","fetch","IDBKeyRange","webSQLStorage","localStorageWrapper","DefinedDrivers","DriverSupport","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","DefaultDriverOrder","LibraryMethods","DefaultConfig","LocalForage","driverTypeKey","driverName","defineDriver","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","config","replace","driverObject","complianceError","driverMethods","concat","customDriverMethod","setDriverSupport","support","info","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","extendSelfWithDriver","_extend","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_getSupportedDrivers","oldDriverSetDone","libraryMethodsAndProperties","createInstance","localforage_js","NgForageConfig","__WEBPACK_IMPORTED_MODULE_2_localforage__","cacheTime","NgForageConfig_1","set","v","configure","opts","assign","spec","toJSON","DRIVER_INDEXEDDB","DRIVER_LOCALSTORAGE","DRIVER_WEBSQL","provider","provide","useFactory","freeze","calculateCacheKeys","mainKey","expiry","toCachedItem","__WEBPACK_IMPORTED_MODULE_4__CachedItemImpl__","head","toVoid","NgForageCache","__WEBPACK_IMPORTED_MODULE_2__main_NgForage_service__","baseConfig","storeNeedsRecalc","getCached","dataPromise","expiryPromise","removeCached","setCached","Date","now","ass","BaseConfigurableImpl","__WEBPACK_IMPORTED_MODULE_3__instance_factory_InstanceFactory_service__","__WEBPACK_IMPORTED_MODULE_4__util_addToStringTag__","__WEBPACK_IMPORTED_MODULE_5__NgForageConfig_service__","instanceFactory","fact","_store","getInstance","finalConfig","getDriverString","sort","join","getHash","cfg","InstanceFactory","stores","InstanceFactory_1","hash","__WEBPACK_IMPORTED_MODULE_0__NgForage_NgForage_module__","__WEBPACK_IMPORTED_MODULE_1__NgForage_cache_NgForageCache_service__","__WEBPACK_IMPORTED_MODULE_2__NgForage_config_NgForageConfig_service__","__WEBPACK_IMPORTED_MODULE_3__NgForage_main_NgForage_service__","NgForageModule","__WEBPACK_IMPORTED_MODULE_2__cache_NgForageCache_service__","__WEBPACK_IMPORTED_MODULE_3__config_BaseConfigurableImpl_service__","__WEBPACK_IMPORTED_MODULE_4__config_NgForageConfig_service__","__WEBPACK_IMPORTED_MODULE_5__instance_factory_InstanceFactory_service__","__WEBPACK_IMPORTED_MODULE_6__main_NgForage_service__","providers","g","Function","eval","CachedItemImpl","__WEBPACK_IMPORTED_MODULE_1_typescript_lazy_get_decorator__","__WEBPACK_IMPORTED_MODULE_2__util_addToStringTag__","expiryTime","expires","expiresIn","Math","max","getTime","expired","hasData","Boolean","Number","LazyGetter","setProto","makeNonConfigurable","descriptor","getOwnPropertyDescriptor","originalMethod","newDescriptor","isStatic","getPrototypeOf"],"mappings":"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","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"tslib\"), require(\"@angular/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"tslib\", \"@angular/core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngForage\"] = factory(require(\"tslib\"), require(\"@angular/core\"));\n\telse\n\t\troot[\"ngForage\"] = factory(root[\"tslib\"], root[\"ng\"][\"core\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"tslib\"), require(\"@angular/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"tslib\", \"@angular/core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ngForage\"] = factory(require(\"tslib\"), require(\"@angular/core\"));\n\telse\n\t\troot[\"ngForage\"] = factory(root[\"tslib\"], root[\"ng\"][\"core\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 9);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return addToStringTag; });\n/** @internal */\r\nvar addToStringTag;\r\nif (typeof Symbol !== 'undefined') {\r\n    addToStringTag = function (target, tag) {\r\n        target.prototype[Symbol['toStringTag']] = tag;\r\n    };\r\n}\r\nelse {\r\n    // tslint:disable-next-line:no-empty\r\n    addToStringTag = function () {\r\n    };\r\n}\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return NgForage; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_BaseConfigurableImpl_service__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__ = __webpack_require__(2);\n\r\n\r\n\r\n\r\n/**\r\n * Cache instance\r\n */\r\nvar NgForage = (function (_super) {\r\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__extends\"](NgForage, _super);\r\n    function NgForage() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(NgForage.prototype, \"activeDriver\", {\r\n        /**\r\n         * Returns the name of the driver being used, or null if none can be used.\r\n         */\r\n        get: function () {\r\n            return this.store.driver();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Removes every key from the database, returning it to a blank slate.\r\n     *\r\n     * clear() will remove <b>every item in the offline store</b>. Use this method with caution.\r\n     */\r\n    NgForage.prototype.clear = function () {\r\n        return this.store.clear();\r\n    };\r\n    /**\r\n     * Gets an item from the storage library.\r\n     * If the key does not exist, getItem() will return null.\r\n     * @param key Data key\r\n     */\r\n    NgForage.prototype.getItem = function (key) {\r\n        return this.store.getItem(key);\r\n    };\r\n    /**\r\n     * Iterate over all value/key pairs in datastore.\r\n     * <i>iteratee</i> is called once for each pair, with the following arguments:\r\n     * <ol>\r\n     *   <li>Value</li>\r\n     *   <li>Key</li>\r\n     *   <li>iterationNumber - one-based number</li>\r\n     * </ol>\r\n     * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.\r\n     * @param iteratee\r\n     */\r\n    NgForage.prototype.iterate = function (iteratee) {\r\n        return this.store.iterate(iteratee);\r\n    };\r\n    /**\r\n     * Get the name of a key based on its ID.\r\n     * @param index\r\n     */\r\n    NgForage.prototype.key = function (index) {\r\n        return this.store.key(index);\r\n    };\r\n    /**\r\n     * Get the list of all keys in the datastore.\r\n     */\r\n    NgForage.prototype.keys = function () {\r\n        return this.store.keys();\r\n    };\r\n    /**\r\n     * Gets the number of keys in the offline store (i.e. its “length”).\r\n     */\r\n    NgForage.prototype.length = function () {\r\n        return this.store.length();\r\n    };\r\n    /**\r\n     * Even though localForage queues up all of its data API method calls,\r\n     * ready() provides a way to determine whether the asynchronous driver initialization process has finished.\r\n     * That’s useful in cases like when we want to know which driver localForage has settled down using.\r\n     */\r\n    NgForage.prototype.ready = function () {\r\n        return this.store.ready();\r\n    };\r\n    /**\r\n     * Removes the value of a key from the offline store.\r\n     * @param key Data key\r\n     */\r\n    NgForage.prototype.removeItem = function (key) {\r\n        return this.store.removeItem(key);\r\n    };\r\n    /**\r\n     * Saves data to an offline store. You can store the following types of JavaScript objects:\r\n     * <ul>\r\n     *  <li>Array</li>\r\n     *  <li>ArrayBuffer</li>\r\n     *  <li>Blob</li>\r\n     *  <li>Float32Array</li>\r\n     *  <li>Float64Array</li>\r\n     *  <li>Int8Array</li>\r\n     *  <li>Int16Array</li>\r\n     *  <li>Int32Array</li>\r\n     *  <li>Number</li>\r\n     *  <li>Object</li>\r\n     *  <li>Uint8Array</li>\r\n     *  <li>Uint8ClampedArray</li>\r\n     *  <li>Uint16Array</li>\r\n     *  <li>Uint32Array</li>\r\n     *  <li>String</li>\r\n     * </ul>\r\n     * @param key Data key\r\n     * @param data Data\r\n     */\r\n    NgForage.prototype.setItem = function (key, data) {\r\n        return this.store.setItem(key, data);\r\n    };\r\n    /**\r\n     * Check whether the given driver is supported/registered.\r\n     * @param driver Driver name\r\n     */\r\n    NgForage.prototype.supports = function (driver) {\r\n        return this.store.supports(driver);\r\n    };\r\n    NgForage = __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"])()\r\n    ], NgForage);\r\n    return NgForage;\r\n}(__WEBPACK_IMPORTED_MODULE_2__config_BaseConfigurableImpl_service__[\"a\" /* BaseConfigurableImpl */]));\r\n\r\nObject(__WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__[\"a\" /* addToStringTag */])(NgForage, 'NgForage');\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.6\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        if (forages[i]._dbInfo.db) {\n            forages[i]._dbInfo.db.close();\n            forages[i]._dbInfo.db = null;\n        }\n    }\n\n    return _getConnection(dbInfo, false).then(function (db) {\n        for (var j = 0; j < forages.length; j++) {\n            forages[j]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback) {\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (!dbInfo.db || err.name === 'InvalidStateError') {\n            return _tryReconnect(dbInfo).then(function () {\n\n                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                callback(null, tx);\n            });\n        }\n\n        callback(err);\n    }\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback retuns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && typeof localStorage.setItem === 'function';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error('Can\\'t call config() after localforage ' + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var customDriverMethod = driverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return NgForageConfig; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_localforage__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_localforage___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_localforage__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__ = __webpack_require__(2);\n\r\n\r\n\r\n\r\n/** @internal */\r\nvar instance;\r\n/** @internal */\r\nvar config = {\r\n    cacheTime: 300000,\r\n    description: '',\r\n    driver: [__WEBPACK_IMPORTED_MODULE_2_localforage__[\"INDEXEDDB\"], __WEBPACK_IMPORTED_MODULE_2_localforage__[\"WEBSQL\"], __WEBPACK_IMPORTED_MODULE_2_localforage__[\"LOCALSTORAGE\"]],\r\n    name: 'ngForage',\r\n    size: 4980736,\r\n    storeName: 'ng_forage',\r\n    version: 1\r\n};\r\n/**\r\n * Global/default configuration\r\n */\r\nvar NgForageConfig = (function () {\r\n    function NgForageConfig() {\r\n    }\r\n    NgForageConfig_1 = NgForageConfig;\r\n    Object.defineProperty(NgForageConfig.prototype, \"cacheTime\", {\r\n        /**\r\n         * Cache time in milliseconds\r\n         * @default 300000\r\n         */\r\n        get: function () {\r\n            return config.cacheTime;\r\n        },\r\n        set: function (t) {\r\n            config.cacheTime = t;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"config\", {\r\n        /**\r\n         * Get the compiled configuration\r\n         */\r\n        get: function () {\r\n            return {\r\n                cacheTime: this.cacheTime,\r\n                description: this.description,\r\n                driver: this.driver,\r\n                name: this.name,\r\n                size: this.size,\r\n                storeName: this.storeName,\r\n                version: this.version\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"description\", {\r\n        /**\r\n         * A description of the database, essentially for developer usage.\r\n         * @default\r\n         */\r\n        get: function () {\r\n            return config.description;\r\n        },\r\n        set: function (v) {\r\n            config.description = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"driver\", {\r\n        /**\r\n         * The preferred driver(s) to use.\r\n         * @see {@link NgForageConfig#DRIVER_INDEXEDDB}\r\n         * @see {@link NgForageConfig#DRIVER_WEBSQL}\r\n         * @see {@link NgForageConfig#DRIVER_LOCALSTORAGE}\r\n         */\r\n        get: function () {\r\n            if (typeof config.driver === 'string') {\r\n                return config.driver;\r\n            }\r\n            return config.driver.slice();\r\n        },\r\n        set: function (v) {\r\n            config.driver = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"name\", {\r\n        /**\r\n         * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.\r\n         * In localStorage, this is used as a key prefix for all keys stored in localStorage.\r\n         * @default ngForage\r\n         */\r\n        get: function () {\r\n            return config.name;\r\n        },\r\n        set: function (v) {\r\n            config.name = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"size\", {\r\n        /**\r\n         * The size of the database in bytes. Used only in WebSQL for now.\r\n         * @default 4980736\r\n         */\r\n        get: function () {\r\n            return config.size;\r\n        },\r\n        set: function (v) {\r\n            config.size = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"storeName\", {\r\n        /**\r\n         * The name of the datastore.\r\n         * In IndexedDB this is the dataStore,\r\n         * in WebSQL this is the name of the key/value table in the database.\r\n         * Must be alphanumeric, with underscores.\r\n         * Any non-alphanumeric characters will be converted to underscores.\r\n         * @default ng_forage\r\n         */\r\n        get: function () {\r\n            return config.storeName;\r\n        },\r\n        set: function (v) {\r\n            config.storeName = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"version\", {\r\n        /**\r\n         * The version of your database. May be used for upgrades in the future; currently unused.\r\n         * @default 1.0\r\n         */\r\n        get: function () {\r\n            return config.version;\r\n        },\r\n        set: function (v) {\r\n            config.version = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgForageConfig.factory = function () {\r\n        if (!instance) {\r\n            instance = new NgForageConfig_1();\r\n        }\r\n        return instance;\r\n    };\r\n    /**\r\n     * Bulk-set configuration options\r\n     * @param opts The configuration\r\n     */\r\n    NgForageConfig.prototype.configure = function (opts) {\r\n        opts = opts || {};\r\n        if ('driver' in opts && opts.driver.slice) {\r\n            opts.driver = opts.driver.slice();\r\n        }\r\n        Object.assign(config, opts);\r\n        return this;\r\n    };\r\n    /**\r\n     * Define a driver\r\n     *\r\n     * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the\r\n     * default drivers do. You’ll also want to resolve or reject promises.\r\n     * Check any of the {@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}\r\n     * for an idea of how to implement your own, custom driver.\r\n     * @param spec Driver spec\r\n     */\r\n    NgForageConfig.prototype.defineDriver = function (spec) {\r\n        return __WEBPACK_IMPORTED_MODULE_2_localforage__[\"defineDriver\"](spec);\r\n    };\r\n    /** @internal */\r\n    NgForageConfig.prototype.toJSON = function () {\r\n        return this.config;\r\n    };\r\n    /** The IndexedDB driver */\r\n    NgForageConfig.DRIVER_INDEXEDDB = __WEBPACK_IMPORTED_MODULE_2_localforage__[\"INDEXEDDB\"];\r\n    /** The localStorage driver */\r\n    NgForageConfig.DRIVER_LOCALSTORAGE = __WEBPACK_IMPORTED_MODULE_2_localforage__[\"LOCALSTORAGE\"];\r\n    /** The WebSQL driver */\r\n    NgForageConfig.DRIVER_WEBSQL = __WEBPACK_IMPORTED_MODULE_2_localforage__[\"WEBSQL\"];\r\n    /** @internal */\r\n    NgForageConfig.provider = {\r\n        provide: NgForageConfig_1,\r\n        useFactory: NgForageConfig_1.factory\r\n    };\r\n    NgForageConfig = NgForageConfig_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"])()\r\n    ], NgForageConfig);\r\n    return NgForageConfig;\r\n    var NgForageConfig_1;\r\n}());\r\n\r\nObject.freeze(NgForageConfig.provider);\r\nObject(__WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__[\"a\" /* addToStringTag */])(NgForageConfig, 'NgForageConfig');\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return NgForageCache; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__main_NgForage_service__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__CachedItemImpl__ = __webpack_require__(12);\n\r\n\r\n\r\n\r\n\r\n/** @internal */\r\nfunction calculateCacheKeys(mainKey) {\r\n    return {\r\n        data: mainKey + \"_data\",\r\n        expiry: mainKey + \"_expiry\"\r\n    };\r\n}\r\n/** @internal */\r\nfunction toCachedItem(r) {\r\n    return new __WEBPACK_IMPORTED_MODULE_4__CachedItemImpl__[\"a\" /* CachedItemImpl */](r[0], r[1]);\r\n}\r\n/** @internal */\r\nfunction head(r) {\r\n    return r[0];\r\n}\r\n/** @internal */\r\n// tslint:disable-next-line:no-empty\r\nfunction toVoid() {\r\n}\r\n/**\r\n * An extension of {@link NgForage} which adds expiration support\r\n */\r\nvar NgForageCache = (function (_super) {\r\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__extends\"](NgForageCache, _super);\r\n    function NgForageCache() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(NgForageCache.prototype, \"cacheTime\", {\r\n        /**\r\n         * Cache time in milliseconds\r\n         * @default 300000\r\n         */\r\n        get: function () {\r\n            return 'cacheTime' in this.config ? this.config.cacheTime : this.baseConfig.cacheTime;\r\n        },\r\n        set: function (t) {\r\n            this.config.cacheTime = t;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Retrieve data\r\n     * @param key Data key\r\n     */\r\n    NgForageCache.prototype.getCached = function (key) {\r\n        var keys = calculateCacheKeys(key);\r\n        var dataPromise = this.getItem(keys.data);\r\n        var expiryPromise = this.getItem(keys.expiry);\r\n        return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);\r\n    };\r\n    /**\r\n     * Remove data\r\n     * @param key Data key\r\n     */\r\n    NgForageCache.prototype.removeCached = function (key) {\r\n        var keys = calculateCacheKeys(key);\r\n        var dataPromise = this.removeItem(keys.data);\r\n        var expiryPromise = this.removeItem(keys.expiry);\r\n        return Promise.all([dataPromise, expiryPromise]).then(toVoid);\r\n    };\r\n    /**\r\n     * Set data\r\n     * @param key Data key\r\n     * @param data Data to set\r\n     * @param [cacheTime] Override cache set in {@link CacheConfigurable#cacheTime global or instance config}.\r\n     */\r\n    NgForageCache.prototype.setCached = function (key, data, cacheTime) {\r\n        var keys = calculateCacheKeys(key);\r\n        var expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;\r\n        var dataPromise = this.setItem(keys.data, data);\r\n        var expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);\r\n        return Promise.all([dataPromise, expiryPromise]).then(head);\r\n    };\r\n    /** @internal */\r\n    NgForageCache.prototype.toJSON = function () {\r\n        var ass = { cacheTime: this.cacheTime };\r\n        return Object.assign(_super.prototype.toJSON.call(this), ass);\r\n    };\r\n    NgForageCache = __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"])()\r\n    ], NgForageCache);\r\n    return NgForageCache;\r\n}(__WEBPACK_IMPORTED_MODULE_2__main_NgForage_service__[\"a\" /* NgForage */]));\r\n\r\nObject(__WEBPACK_IMPORTED_MODULE_3__util_addToStringTag__[\"a\" /* addToStringTag */])(NgForageCache, 'NgForageCache');\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BaseConfigurableImpl; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_localforage__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_localforage___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_localforage__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__instance_factory_InstanceFactory_service__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_addToStringTag__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__NgForageConfig_service__ = __webpack_require__(5);\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Abstract service-level configuration layer for NgForage\r\n */\r\nvar BaseConfigurableImpl = (function () {\r\n    /** @internal */\r\n    function BaseConfigurableImpl(config, instanceFactory) {\r\n        /** @internal */\r\n        this.config = {};\r\n        /** @internal */\r\n        this.storeNeedsRecalc = true;\r\n        this.baseConfig = config;\r\n        this.fact = instanceFactory;\r\n    }\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"description\", {\r\n        /**\r\n         * A description of the database, essentially for developer usage.\r\n         * @default \"\"\r\n         */\r\n        get: function () {\r\n            return 'description' in this.config ? this.config.description : this.baseConfig.description;\r\n        },\r\n        set: function (v) {\r\n            this.config.description = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"driver\", {\r\n        /**\r\n         * The preferred driver(s) to use.\r\n         * @see {@link NgForageConfig#DRIVER_INDEXEDDB}\r\n         * @see {@link NgForageConfig#DRIVER_WEBSQL}\r\n         * @see {@link NgForageConfig#DRIVER_LOCALSTORAGE}\r\n         * @default IndexedDB, WebSQL and localStorage\r\n         */\r\n        get: function () {\r\n            return 'driver' in this.config ? this.config.driver : this.baseConfig.driver;\r\n        },\r\n        set: function (v) {\r\n            this.config.driver = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"name\", {\r\n        /**\r\n         * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.\r\n         * In localStorage, this is used as a key prefix for all keys stored in localStorage.\r\n         * @default ngForage\r\n         */\r\n        get: function () {\r\n            return 'name' in this.config ? this.config.name : this.baseConfig.name;\r\n        },\r\n        set: function (v) {\r\n            this.config.name = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"size\", {\r\n        /**\r\n         * The size of the database in bytes. Used only in WebSQL for now.\r\n         * @default 4980736\r\n         */\r\n        get: function () {\r\n            return 'size' in this.config ? this.config.size : this.baseConfig.size;\r\n        },\r\n        set: function (v) {\r\n            this.config.size = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"storeName\", {\r\n        /**\r\n         * The name of the datastore.\r\n         * In IndexedDB this is the dataStore,\r\n         * in WebSQL this is the name of the key/value table in the database.\r\n         * Must be alphanumeric, with underscores.\r\n         * Any non-alphanumeric characters will be converted to underscores.\r\n         * @default ng_forage\r\n         */\r\n        get: function () {\r\n            return 'storeName' in this.config ? this.config.storeName : this.baseConfig.storeName;\r\n        },\r\n        set: function (v) {\r\n            this.config.storeName = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"version\", {\r\n        /**\r\n         * The version of your database. May be used for upgrades in the future; currently unused.\r\n         * @default 1.0\r\n         */\r\n        get: function () {\r\n            return 'version' in this.config ? this.config.version : this.baseConfig.version;\r\n        },\r\n        set: function (v) {\r\n            this.config.version = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"store\", {\r\n        /** @internal */\r\n        get: function () {\r\n            if (this.storeNeedsRecalc || !this._store) {\r\n                this._store = this.fact.getInstance(this.finalConfig);\r\n                this.storeNeedsRecalc = false;\r\n            }\r\n            return this._store;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"finalConfig\", {\r\n        /** @internal */\r\n        get: function () {\r\n            return Object.assign({}, this.baseConfig.config, this.config);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Bulk-set configuration options\r\n     * @param opts The configuration\r\n     */\r\n    BaseConfigurableImpl.prototype.configure = function (opts) {\r\n        opts = opts || {};\r\n        if ('driver' in opts && opts.driver.slice) {\r\n            opts.driver = opts.driver.slice();\r\n        }\r\n        Object.assign(this.config, opts);\r\n        this.storeNeedsRecalc = true;\r\n        return this;\r\n    };\r\n    /** @internal */\r\n    BaseConfigurableImpl.prototype.toJSON = function () {\r\n        return {\r\n            description: this.description,\r\n            driver: this.driver,\r\n            name: this.name,\r\n            size: this.size,\r\n            storeName: this.storeName,\r\n            version: this.version\r\n        };\r\n    };\r\n    BaseConfigurableImpl = __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"])(),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__param\"](0, Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"])(__WEBPACK_IMPORTED_MODULE_5__NgForageConfig_service__[\"a\" /* NgForageConfig */])),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__param\"](1, Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Inject\"])(__WEBPACK_IMPORTED_MODULE_3__instance_factory_InstanceFactory_service__[\"a\" /* InstanceFactory */])),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:paramtypes\", [__WEBPACK_IMPORTED_MODULE_5__NgForageConfig_service__[\"a\" /* NgForageConfig */],\r\n            __WEBPACK_IMPORTED_MODULE_3__instance_factory_InstanceFactory_service__[\"a\" /* InstanceFactory */]])\r\n    ], BaseConfigurableImpl);\r\n    return BaseConfigurableImpl;\r\n}());\r\n\r\nObject(__WEBPACK_IMPORTED_MODULE_4__util_addToStringTag__[\"a\" /* addToStringTag */])(BaseConfigurableImpl, 'BaseConfigurable');\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InstanceFactory; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_localforage__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_localforage___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_localforage__);\n\r\n\r\n\r\n/** @internal */\r\nvar instance;\r\n/** @internal */\r\nvar stores = {};\r\n/** @internal */\r\nfunction getDriverString(driver) {\r\n    if (!driver) {\r\n        return '';\r\n    }\r\n    else if (typeof driver === 'string') {\r\n        return driver;\r\n    }\r\n    else {\r\n        return driver.slice().sort().join(',');\r\n    }\r\n}\r\n/** @internal */\r\nfunction getHash(cfg) {\r\n    return [\r\n        getDriverString(cfg.driver),\r\n        cfg.name,\r\n        cfg.size,\r\n        cfg.storeName,\r\n        cfg.version,\r\n        cfg.description,\r\n        cfg.cacheTime\r\n    ].join('|');\r\n}\r\n/**\r\n * Creates localForage instances\r\n */\r\nvar InstanceFactory = (function () {\r\n    function InstanceFactory() {\r\n    }\r\n    InstanceFactory_1 = InstanceFactory;\r\n    InstanceFactory.factory = function () {\r\n        if (!instance) {\r\n            instance = new InstanceFactory_1();\r\n        }\r\n        return instance;\r\n    };\r\n    /** @internal */\r\n    InstanceFactory.prototype.getInstance = function (cfg) {\r\n        var hash = getHash(cfg);\r\n        if (!stores[hash]) {\r\n            stores[hash] = __WEBPACK_IMPORTED_MODULE_2_localforage__[\"createInstance\"](cfg);\r\n        }\r\n        return stores[hash];\r\n    };\r\n    /** @internal */\r\n    InstanceFactory.provider = {\r\n        provide: InstanceFactory_1,\r\n        useFactory: InstanceFactory_1.factory\r\n    };\r\n    InstanceFactory = InstanceFactory_1 = __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Injectable\"])()\r\n    ], InstanceFactory);\r\n    return InstanceFactory;\r\n    var InstanceFactory_1;\r\n}());\r\n\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__NgForage_NgForage_module__ = __webpack_require__(10);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"NgForageModule\", function() { return __WEBPACK_IMPORTED_MODULE_0__NgForage_NgForage_module__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__NgForage_cache_NgForageCache_service__ = __webpack_require__(6);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"NgForageCache\", function() { return __WEBPACK_IMPORTED_MODULE_1__NgForage_cache_NgForageCache_service__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__NgForage_config_NgForageConfig_service__ = __webpack_require__(5);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"NgForageConfig\", function() { return __WEBPACK_IMPORTED_MODULE_2__NgForage_config_NgForageConfig_service__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__NgForage_main_NgForage_service__ = __webpack_require__(3);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"NgForage\", function() { return __WEBPACK_IMPORTED_MODULE_3__NgForage_main_NgForage_service__[\"a\"]; });\n\r\n\r\n\r\n\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return NgForageModule; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__angular_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__cache_NgForageCache_service__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_BaseConfigurableImpl_service__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_NgForageConfig_service__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__instance_factory_InstanceFactory_service__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__main_NgForage_service__ = __webpack_require__(3);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * NgForage core module\r\n */\r\nvar NgForageModule = (function () {\r\n    function NgForageModule() {\r\n    }\r\n    NgForageModule = __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"NgModule\"])({\r\n            providers: [\r\n                __WEBPACK_IMPORTED_MODULE_6__main_NgForage_service__[\"a\" /* NgForage */],\r\n                __WEBPACK_IMPORTED_MODULE_2__cache_NgForageCache_service__[\"a\" /* NgForageCache */],\r\n                __WEBPACK_IMPORTED_MODULE_3__config_BaseConfigurableImpl_service__[\"a\" /* BaseConfigurableImpl */],\r\n                __WEBPACK_IMPORTED_MODULE_4__config_NgForageConfig_service__[\"a\" /* NgForageConfig */].provider,\r\n                __WEBPACK_IMPORTED_MODULE_5__instance_factory_InstanceFactory_service__[\"a\" /* InstanceFactory */].provider\r\n            ]\r\n        })\r\n    ], NgForageModule);\r\n    return NgForageModule;\r\n}());\r\n\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CachedItemImpl; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tslib___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tslib__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_typescript_lazy_get_decorator__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_addToStringTag__ = __webpack_require__(2);\n\r\n\r\n\r\n/** @internal */\r\nvar CachedItemImpl = (function () {\r\n    function CachedItemImpl(data, expiryTime) {\r\n        this.data = data;\r\n        this.expires = new Date(typeof expiryTime === 'number' ? expiryTime : 0);\r\n    }\r\n    Object.defineProperty(CachedItemImpl.prototype, \"expired\", {\r\n        get: function () {\r\n            return this.expiresIn === 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CachedItemImpl.prototype, \"expiresIn\", {\r\n        get: function () {\r\n            return Math.max(0, this.expires.getTime() - Date.now());\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CachedItemImpl.prototype, \"hasData\", {\r\n        get: function () {\r\n            return this.data !== null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    CachedItemImpl.prototype.toJSON = function () {\r\n        return {\r\n            data: this.data,\r\n            expired: this.expired,\r\n            expires: this.expires,\r\n            expiresIn: this.expiresIn,\r\n            hasData: this.hasData\r\n        };\r\n    };\r\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1_typescript_lazy_get_decorator__[\"a\" /* LazyGetter */])(),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:type\", Boolean),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:paramtypes\", [])\r\n    ], CachedItemImpl.prototype, \"expired\", null);\r\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1_typescript_lazy_get_decorator__[\"a\" /* LazyGetter */])(),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:type\", Number),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:paramtypes\", [])\r\n    ], CachedItemImpl.prototype, \"expiresIn\", null);\r\n    __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__decorate\"]([\r\n        Object(__WEBPACK_IMPORTED_MODULE_1_typescript_lazy_get_decorator__[\"a\" /* LazyGetter */])(),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:type\", Boolean),\r\n        __WEBPACK_IMPORTED_MODULE_0_tslib__[\"__metadata\"](\"design:paramtypes\", [])\r\n    ], CachedItemImpl.prototype, \"hasData\", null);\r\n    return CachedItemImpl;\r\n}());\r\n\r\nObject(__WEBPACK_IMPORTED_MODULE_2__util_addToStringTag__[\"a\" /* addToStringTag */])(CachedItemImpl, 'CachedItem');\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = LazyGetter;\n/**\n * Evaluate the getter function and cache the result\n * @param {boolean} [setProto=false] Set the value on the class prototype as well. Only applies to non-static getters.\n * @param {boolean} [makeNonConfigurable=false] Set to true to make the resolved property non-configurable\n * @return {(target: any, key: string, descriptor: PropertyDescriptor) => void} A Typescript decorator function\n */\nfunction LazyGetter(setProto, makeNonConfigurable) {\n    if (setProto === void 0) { setProto = false; }\n    if (makeNonConfigurable === void 0) { makeNonConfigurable = false; }\n    return function (target, key, descriptor) {\n        if (!descriptor) {\n            descriptor = Object.getOwnPropertyDescriptor(target, key);\n        }\n        var originalMethod = descriptor.get;\n        if (!originalMethod) {\n            throw new Error('@LazyGetter can only decorate getters!');\n        }\n        else if (!descriptor.configurable) {\n            throw new Error('@LazyGetter target must be configurable');\n        }\n        else {\n            descriptor.get = function () {\n                var value = originalMethod.apply(this, arguments);\n                var newDescriptor = {\n                    configurable: !makeNonConfigurable,\n                    enumerable: descriptor.enumerable,\n                    value: value\n                };\n                var isStatic = Object.getPrototypeOf(target) === Function.prototype;\n                if (isStatic || setProto) {\n                    Object.defineProperty(target, key, newDescriptor);\n                }\n                if (!isStatic) {\n                    Object.defineProperty(this, key, newDescriptor);\n                }\n                return value;\n            };\n        }\n    };\n}\n//# sourceMappingURL=LazyGetter.js.map\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// index.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7ab7d4a5f88fe9838b1c","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"tslib\"\n// module id = 0\n// module chunks = 0 1","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":[\"ng\",\"core\"],\"commonjs\":\"@angular/core\",\"commonjs2\":\"@angular/core\",\"amd\":\"@angular/core\"}\n// module id = 1\n// module chunks = 0 1","/** @internal */\r\nexport var addToStringTag;\r\nif (typeof Symbol !== 'undefined') {\r\n    addToStringTag = function (target, tag) {\r\n        target.prototype[Symbol['toStringTag']] = tag;\r\n    };\r\n}\r\nelse {\r\n    // tslint:disable-next-line:no-empty\r\n    addToStringTag = function () {\r\n    };\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/util/addToStringTag.ts\n// module id = 2\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { Injectable } from '@angular/core';\r\nimport { BaseConfigurableImpl } from '../config/BaseConfigurableImpl.service';\r\nimport { addToStringTag } from '../util/addToStringTag';\r\n/**\r\n * Cache instance\r\n */\r\nvar NgForage = (function (_super) {\r\n    tslib_1.__extends(NgForage, _super);\r\n    function NgForage() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(NgForage.prototype, \"activeDriver\", {\r\n        /**\r\n         * Returns the name of the driver being used, or null if none can be used.\r\n         */\r\n        get: function () {\r\n            return this.store.driver();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Removes every key from the database, returning it to a blank slate.\r\n     *\r\n     * clear() will remove <b>every item in the offline store</b>. Use this method with caution.\r\n     */\r\n    NgForage.prototype.clear = function () {\r\n        return this.store.clear();\r\n    };\r\n    /**\r\n     * Gets an item from the storage library.\r\n     * If the key does not exist, getItem() will return null.\r\n     * @param key Data key\r\n     */\r\n    NgForage.prototype.getItem = function (key) {\r\n        return this.store.getItem(key);\r\n    };\r\n    /**\r\n     * Iterate over all value/key pairs in datastore.\r\n     * <i>iteratee</i> is called once for each pair, with the following arguments:\r\n     * <ol>\r\n     *   <li>Value</li>\r\n     *   <li>Key</li>\r\n     *   <li>iterationNumber - one-based number</li>\r\n     * </ol>\r\n     * iterate() supports early exit by returning non undefined value inside iteratorCallback callback.\r\n     * @param iteratee\r\n     */\r\n    NgForage.prototype.iterate = function (iteratee) {\r\n        return this.store.iterate(iteratee);\r\n    };\r\n    /**\r\n     * Get the name of a key based on its ID.\r\n     * @param index\r\n     */\r\n    NgForage.prototype.key = function (index) {\r\n        return this.store.key(index);\r\n    };\r\n    /**\r\n     * Get the list of all keys in the datastore.\r\n     */\r\n    NgForage.prototype.keys = function () {\r\n        return this.store.keys();\r\n    };\r\n    /**\r\n     * Gets the number of keys in the offline store (i.e. its “length”).\r\n     */\r\n    NgForage.prototype.length = function () {\r\n        return this.store.length();\r\n    };\r\n    /**\r\n     * Even though localForage queues up all of its data API method calls,\r\n     * ready() provides a way to determine whether the asynchronous driver initialization process has finished.\r\n     * That’s useful in cases like when we want to know which driver localForage has settled down using.\r\n     */\r\n    NgForage.prototype.ready = function () {\r\n        return this.store.ready();\r\n    };\r\n    /**\r\n     * Removes the value of a key from the offline store.\r\n     * @param key Data key\r\n     */\r\n    NgForage.prototype.removeItem = function (key) {\r\n        return this.store.removeItem(key);\r\n    };\r\n    /**\r\n     * Saves data to an offline store. You can store the following types of JavaScript objects:\r\n     * <ul>\r\n     *  <li>Array</li>\r\n     *  <li>ArrayBuffer</li>\r\n     *  <li>Blob</li>\r\n     *  <li>Float32Array</li>\r\n     *  <li>Float64Array</li>\r\n     *  <li>Int8Array</li>\r\n     *  <li>Int16Array</li>\r\n     *  <li>Int32Array</li>\r\n     *  <li>Number</li>\r\n     *  <li>Object</li>\r\n     *  <li>Uint8Array</li>\r\n     *  <li>Uint8ClampedArray</li>\r\n     *  <li>Uint16Array</li>\r\n     *  <li>Uint32Array</li>\r\n     *  <li>String</li>\r\n     * </ul>\r\n     * @param key Data key\r\n     * @param data Data\r\n     */\r\n    NgForage.prototype.setItem = function (key, data) {\r\n        return this.store.setItem(key, data);\r\n    };\r\n    /**\r\n     * Check whether the given driver is supported/registered.\r\n     * @param driver Driver name\r\n     */\r\n    NgForage.prototype.supports = function (driver) {\r\n        return this.store.supports(driver);\r\n    };\r\n    NgForage = tslib_1.__decorate([\r\n        Injectable()\r\n    ], NgForage);\r\n    return NgForage;\r\n}(BaseConfigurableImpl));\r\nexport { NgForage };\r\naddToStringTag(NgForage, 'NgForage');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/main/NgForage.service.ts\n// module id = 3\n// module chunks = 0 1","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.6\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        if (forages[i]._dbInfo.db) {\n            forages[i]._dbInfo.db.close();\n            forages[i]._dbInfo.db = null;\n        }\n    }\n\n    return _getConnection(dbInfo, false).then(function (db) {\n        for (var j = 0; j < forages.length; j++) {\n            forages[j]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback) {\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (!dbInfo.db || err.name === 'InvalidStateError') {\n            return _tryReconnect(dbInfo).then(function () {\n\n                var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n                callback(null, tx);\n            });\n        }\n\n        callback(err);\n    }\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback retuns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && typeof localStorage.setItem === 'function';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error('Can\\'t call config() after localforage ' + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var customDriverMethod = driverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/localforage/dist/localforage.js\n// module id = 4\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { Injectable } from '@angular/core';\r\nimport * as lf from 'localforage';\r\nimport { addToStringTag } from '../util/addToStringTag';\r\n/** @internal */\r\nvar instance;\r\n/** @internal */\r\nvar config = {\r\n    cacheTime: 300000,\r\n    description: '',\r\n    driver: [lf.INDEXEDDB, lf.WEBSQL, lf.LOCALSTORAGE],\r\n    name: 'ngForage',\r\n    size: 4980736,\r\n    storeName: 'ng_forage',\r\n    version: 1\r\n};\r\n/**\r\n * Global/default configuration\r\n */\r\nvar NgForageConfig = (function () {\r\n    function NgForageConfig() {\r\n    }\r\n    NgForageConfig_1 = NgForageConfig;\r\n    Object.defineProperty(NgForageConfig.prototype, \"cacheTime\", {\r\n        /**\r\n         * Cache time in milliseconds\r\n         * @default 300000\r\n         */\r\n        get: function () {\r\n            return config.cacheTime;\r\n        },\r\n        set: function (t) {\r\n            config.cacheTime = t;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"config\", {\r\n        /**\r\n         * Get the compiled configuration\r\n         */\r\n        get: function () {\r\n            return {\r\n                cacheTime: this.cacheTime,\r\n                description: this.description,\r\n                driver: this.driver,\r\n                name: this.name,\r\n                size: this.size,\r\n                storeName: this.storeName,\r\n                version: this.version\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"description\", {\r\n        /**\r\n         * A description of the database, essentially for developer usage.\r\n         * @default\r\n         */\r\n        get: function () {\r\n            return config.description;\r\n        },\r\n        set: function (v) {\r\n            config.description = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"driver\", {\r\n        /**\r\n         * The preferred driver(s) to use.\r\n         * @see {@link NgForageConfig#DRIVER_INDEXEDDB}\r\n         * @see {@link NgForageConfig#DRIVER_WEBSQL}\r\n         * @see {@link NgForageConfig#DRIVER_LOCALSTORAGE}\r\n         */\r\n        get: function () {\r\n            if (typeof config.driver === 'string') {\r\n                return config.driver;\r\n            }\r\n            return config.driver.slice();\r\n        },\r\n        set: function (v) {\r\n            config.driver = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"name\", {\r\n        /**\r\n         * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.\r\n         * In localStorage, this is used as a key prefix for all keys stored in localStorage.\r\n         * @default ngForage\r\n         */\r\n        get: function () {\r\n            return config.name;\r\n        },\r\n        set: function (v) {\r\n            config.name = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"size\", {\r\n        /**\r\n         * The size of the database in bytes. Used only in WebSQL for now.\r\n         * @default 4980736\r\n         */\r\n        get: function () {\r\n            return config.size;\r\n        },\r\n        set: function (v) {\r\n            config.size = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"storeName\", {\r\n        /**\r\n         * The name of the datastore.\r\n         * In IndexedDB this is the dataStore,\r\n         * in WebSQL this is the name of the key/value table in the database.\r\n         * Must be alphanumeric, with underscores.\r\n         * Any non-alphanumeric characters will be converted to underscores.\r\n         * @default ng_forage\r\n         */\r\n        get: function () {\r\n            return config.storeName;\r\n        },\r\n        set: function (v) {\r\n            config.storeName = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(NgForageConfig.prototype, \"version\", {\r\n        /**\r\n         * The version of your database. May be used for upgrades in the future; currently unused.\r\n         * @default 1.0\r\n         */\r\n        get: function () {\r\n            return config.version;\r\n        },\r\n        set: function (v) {\r\n            config.version = v;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    NgForageConfig.factory = function () {\r\n        if (!instance) {\r\n            instance = new NgForageConfig_1();\r\n        }\r\n        return instance;\r\n    };\r\n    /**\r\n     * Bulk-set configuration options\r\n     * @param opts The configuration\r\n     */\r\n    NgForageConfig.prototype.configure = function (opts) {\r\n        opts = opts || {};\r\n        if ('driver' in opts && opts.driver.slice) {\r\n            opts.driver = opts.driver.slice();\r\n        }\r\n        Object.assign(config, opts);\r\n        return this;\r\n    };\r\n    /**\r\n     * Define a driver\r\n     *\r\n     * You’ll want to make sure you accept a callback argument and that you pass the same arguments to callbacks as the\r\n     * default drivers do. You’ll also want to resolve or reject promises.\r\n     * Check any of the {@link https://github.com/mozilla/localForage/tree/master/src/drivers default drivers}\r\n     * for an idea of how to implement your own, custom driver.\r\n     * @param spec Driver spec\r\n     */\r\n    NgForageConfig.prototype.defineDriver = function (spec) {\r\n        return lf.defineDriver(spec);\r\n    };\r\n    /** @internal */\r\n    NgForageConfig.prototype.toJSON = function () {\r\n        return this.config;\r\n    };\r\n    /** The IndexedDB driver */\r\n    NgForageConfig.DRIVER_INDEXEDDB = lf.INDEXEDDB;\r\n    /** The localStorage driver */\r\n    NgForageConfig.DRIVER_LOCALSTORAGE = lf.LOCALSTORAGE;\r\n    /** The WebSQL driver */\r\n    NgForageConfig.DRIVER_WEBSQL = lf.WEBSQL;\r\n    /** @internal */\r\n    NgForageConfig.provider = {\r\n        provide: NgForageConfig_1,\r\n        useFactory: NgForageConfig_1.factory\r\n    };\r\n    NgForageConfig = NgForageConfig_1 = tslib_1.__decorate([\r\n        Injectable()\r\n    ], NgForageConfig);\r\n    return NgForageConfig;\r\n    var NgForageConfig_1;\r\n}());\r\nexport { NgForageConfig };\r\nObject.freeze(NgForageConfig.provider);\r\naddToStringTag(NgForageConfig, 'NgForageConfig');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/config/NgForageConfig.service.ts\n// module id = 5\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { Injectable } from '@angular/core';\r\nimport { NgForage } from '../main/NgForage.service';\r\nimport { addToStringTag } from '../util/addToStringTag';\r\nimport { CachedItemImpl } from './CachedItemImpl';\r\n/** @internal */\r\nfunction calculateCacheKeys(mainKey) {\r\n    return {\r\n        data: mainKey + \"_data\",\r\n        expiry: mainKey + \"_expiry\"\r\n    };\r\n}\r\n/** @internal */\r\nfunction toCachedItem(r) {\r\n    return new CachedItemImpl(r[0], r[1]);\r\n}\r\n/** @internal */\r\nfunction head(r) {\r\n    return r[0];\r\n}\r\n/** @internal */\r\n// tslint:disable-next-line:no-empty\r\nfunction toVoid() {\r\n}\r\n/**\r\n * An extension of {@link NgForage} which adds expiration support\r\n */\r\nvar NgForageCache = (function (_super) {\r\n    tslib_1.__extends(NgForageCache, _super);\r\n    function NgForageCache() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    Object.defineProperty(NgForageCache.prototype, \"cacheTime\", {\r\n        /**\r\n         * Cache time in milliseconds\r\n         * @default 300000\r\n         */\r\n        get: function () {\r\n            return 'cacheTime' in this.config ? this.config.cacheTime : this.baseConfig.cacheTime;\r\n        },\r\n        set: function (t) {\r\n            this.config.cacheTime = t;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Retrieve data\r\n     * @param key Data key\r\n     */\r\n    NgForageCache.prototype.getCached = function (key) {\r\n        var keys = calculateCacheKeys(key);\r\n        var dataPromise = this.getItem(keys.data);\r\n        var expiryPromise = this.getItem(keys.expiry);\r\n        return Promise.all([dataPromise, expiryPromise]).then(toCachedItem);\r\n    };\r\n    /**\r\n     * Remove data\r\n     * @param key Data key\r\n     */\r\n    NgForageCache.prototype.removeCached = function (key) {\r\n        var keys = calculateCacheKeys(key);\r\n        var dataPromise = this.removeItem(keys.data);\r\n        var expiryPromise = this.removeItem(keys.expiry);\r\n        return Promise.all([dataPromise, expiryPromise]).then(toVoid);\r\n    };\r\n    /**\r\n     * Set data\r\n     * @param key Data key\r\n     * @param data Data to set\r\n     * @param [cacheTime] Override cache set in {@link CacheConfigurable#cacheTime global or instance config}.\r\n     */\r\n    NgForageCache.prototype.setCached = function (key, data, cacheTime) {\r\n        var keys = calculateCacheKeys(key);\r\n        var expiry = typeof cacheTime === 'number' ? cacheTime : this.cacheTime;\r\n        var dataPromise = this.setItem(keys.data, data);\r\n        var expiryPromise = this.setItem(keys.expiry, Date.now() + expiry);\r\n        return Promise.all([dataPromise, expiryPromise]).then(head);\r\n    };\r\n    /** @internal */\r\n    NgForageCache.prototype.toJSON = function () {\r\n        var ass = { cacheTime: this.cacheTime };\r\n        return Object.assign(_super.prototype.toJSON.call(this), ass);\r\n    };\r\n    NgForageCache = tslib_1.__decorate([\r\n        Injectable()\r\n    ], NgForageCache);\r\n    return NgForageCache;\r\n}(NgForage));\r\nexport { NgForageCache };\r\naddToStringTag(NgForageCache, 'NgForageCache');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/cache/NgForageCache.service.ts\n// module id = 6\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { Inject, Injectable } from '@angular/core';\r\nimport 'localforage';\r\nimport { InstanceFactory } from '../instance-factory/InstanceFactory.service';\r\nimport { addToStringTag } from '../util/addToStringTag';\r\nimport { NgForageConfig } from './NgForageConfig.service';\r\n/**\r\n * Abstract service-level configuration layer for NgForage\r\n */\r\nvar BaseConfigurableImpl = (function () {\r\n    /** @internal */\r\n    function BaseConfigurableImpl(config, instanceFactory) {\r\n        /** @internal */\r\n        this.config = {};\r\n        /** @internal */\r\n        this.storeNeedsRecalc = true;\r\n        this.baseConfig = config;\r\n        this.fact = instanceFactory;\r\n    }\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"description\", {\r\n        /**\r\n         * A description of the database, essentially for developer usage.\r\n         * @default \"\"\r\n         */\r\n        get: function () {\r\n            return 'description' in this.config ? this.config.description : this.baseConfig.description;\r\n        },\r\n        set: function (v) {\r\n            this.config.description = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"driver\", {\r\n        /**\r\n         * The preferred driver(s) to use.\r\n         * @see {@link NgForageConfig#DRIVER_INDEXEDDB}\r\n         * @see {@link NgForageConfig#DRIVER_WEBSQL}\r\n         * @see {@link NgForageConfig#DRIVER_LOCALSTORAGE}\r\n         * @default IndexedDB, WebSQL and localStorage\r\n         */\r\n        get: function () {\r\n            return 'driver' in this.config ? this.config.driver : this.baseConfig.driver;\r\n        },\r\n        set: function (v) {\r\n            this.config.driver = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"name\", {\r\n        /**\r\n         * The name of the database. May appear during storage limit prompts. Useful to use the name of your app here.\r\n         * In localStorage, this is used as a key prefix for all keys stored in localStorage.\r\n         * @default ngForage\r\n         */\r\n        get: function () {\r\n            return 'name' in this.config ? this.config.name : this.baseConfig.name;\r\n        },\r\n        set: function (v) {\r\n            this.config.name = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"size\", {\r\n        /**\r\n         * The size of the database in bytes. Used only in WebSQL for now.\r\n         * @default 4980736\r\n         */\r\n        get: function () {\r\n            return 'size' in this.config ? this.config.size : this.baseConfig.size;\r\n        },\r\n        set: function (v) {\r\n            this.config.size = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"storeName\", {\r\n        /**\r\n         * The name of the datastore.\r\n         * In IndexedDB this is the dataStore,\r\n         * in WebSQL this is the name of the key/value table in the database.\r\n         * Must be alphanumeric, with underscores.\r\n         * Any non-alphanumeric characters will be converted to underscores.\r\n         * @default ng_forage\r\n         */\r\n        get: function () {\r\n            return 'storeName' in this.config ? this.config.storeName : this.baseConfig.storeName;\r\n        },\r\n        set: function (v) {\r\n            this.config.storeName = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"version\", {\r\n        /**\r\n         * The version of your database. May be used for upgrades in the future; currently unused.\r\n         * @default 1.0\r\n         */\r\n        get: function () {\r\n            return 'version' in this.config ? this.config.version : this.baseConfig.version;\r\n        },\r\n        set: function (v) {\r\n            this.config.version = v;\r\n            this.storeNeedsRecalc = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"store\", {\r\n        /** @internal */\r\n        get: function () {\r\n            if (this.storeNeedsRecalc || !this._store) {\r\n                this._store = this.fact.getInstance(this.finalConfig);\r\n                this.storeNeedsRecalc = false;\r\n            }\r\n            return this._store;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(BaseConfigurableImpl.prototype, \"finalConfig\", {\r\n        /** @internal */\r\n        get: function () {\r\n            return Object.assign({}, this.baseConfig.config, this.config);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Bulk-set configuration options\r\n     * @param opts The configuration\r\n     */\r\n    BaseConfigurableImpl.prototype.configure = function (opts) {\r\n        opts = opts || {};\r\n        if ('driver' in opts && opts.driver.slice) {\r\n            opts.driver = opts.driver.slice();\r\n        }\r\n        Object.assign(this.config, opts);\r\n        this.storeNeedsRecalc = true;\r\n        return this;\r\n    };\r\n    /** @internal */\r\n    BaseConfigurableImpl.prototype.toJSON = function () {\r\n        return {\r\n            description: this.description,\r\n            driver: this.driver,\r\n            name: this.name,\r\n            size: this.size,\r\n            storeName: this.storeName,\r\n            version: this.version\r\n        };\r\n    };\r\n    BaseConfigurableImpl = tslib_1.__decorate([\r\n        Injectable(),\r\n        tslib_1.__param(0, Inject(NgForageConfig)),\r\n        tslib_1.__param(1, Inject(InstanceFactory)),\r\n        tslib_1.__metadata(\"design:paramtypes\", [NgForageConfig,\r\n            InstanceFactory])\r\n    ], BaseConfigurableImpl);\r\n    return BaseConfigurableImpl;\r\n}());\r\nexport { BaseConfigurableImpl };\r\naddToStringTag(BaseConfigurableImpl, 'BaseConfigurable');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/config/BaseConfigurableImpl.service.ts\n// module id = 7\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { Injectable } from '@angular/core';\r\nimport * as lf from 'localforage';\r\n/** @internal */\r\nvar instance;\r\n/** @internal */\r\nvar stores = {};\r\n/** @internal */\r\nfunction getDriverString(driver) {\r\n    if (!driver) {\r\n        return '';\r\n    }\r\n    else if (typeof driver === 'string') {\r\n        return driver;\r\n    }\r\n    else {\r\n        return driver.slice().sort().join(',');\r\n    }\r\n}\r\n/** @internal */\r\nfunction getHash(cfg) {\r\n    return [\r\n        getDriverString(cfg.driver),\r\n        cfg.name,\r\n        cfg.size,\r\n        cfg.storeName,\r\n        cfg.version,\r\n        cfg.description,\r\n        cfg.cacheTime\r\n    ].join('|');\r\n}\r\n/**\r\n * Creates localForage instances\r\n */\r\nvar InstanceFactory = (function () {\r\n    function InstanceFactory() {\r\n    }\r\n    InstanceFactory_1 = InstanceFactory;\r\n    InstanceFactory.factory = function () {\r\n        if (!instance) {\r\n            instance = new InstanceFactory_1();\r\n        }\r\n        return instance;\r\n    };\r\n    /** @internal */\r\n    InstanceFactory.prototype.getInstance = function (cfg) {\r\n        var hash = getHash(cfg);\r\n        if (!stores[hash]) {\r\n            stores[hash] = lf.createInstance(cfg);\r\n        }\r\n        return stores[hash];\r\n    };\r\n    /** @internal */\r\n    InstanceFactory.provider = {\r\n        provide: InstanceFactory_1,\r\n        useFactory: InstanceFactory_1.factory\r\n    };\r\n    InstanceFactory = InstanceFactory_1 = tslib_1.__decorate([\r\n        Injectable()\r\n    ], InstanceFactory);\r\n    return InstanceFactory;\r\n    var InstanceFactory_1;\r\n}());\r\nexport { InstanceFactory };\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/instance-factory/InstanceFactory.service.ts\n// module id = 8\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { NgModule } from '@angular/core';\r\nimport { NgForageCache } from './cache/NgForageCache.service';\r\nimport { BaseConfigurableImpl } from './config/BaseConfigurableImpl.service';\r\nimport { NgForageConfig } from './config/NgForageConfig.service';\r\nimport { InstanceFactory } from './instance-factory/InstanceFactory.service';\r\nimport { NgForage } from './main/NgForage.service';\r\n/**\r\n * NgForage core module\r\n */\r\nvar NgForageModule = (function () {\r\n    function NgForageModule() {\r\n    }\r\n    NgForageModule = tslib_1.__decorate([\r\n        NgModule({\r\n            providers: [\r\n                NgForage,\r\n                NgForageCache,\r\n                BaseConfigurableImpl,\r\n                NgForageConfig.provider,\r\n                InstanceFactory.provider\r\n            ]\r\n        })\r\n    ], NgForageModule);\r\n    return NgForageModule;\r\n}());\r\nexport { NgForageModule };\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/NgForage.module.ts\n// module id = 10\n// module chunks = 0 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 11\n// module chunks = 0 1","import * as tslib_1 from \"tslib\";\r\nimport { LazyGetter } from 'typescript-lazy-get-decorator';\r\nimport { addToStringTag } from '../util/addToStringTag';\r\n/** @internal */\r\nvar CachedItemImpl = (function () {\r\n    function CachedItemImpl(data, expiryTime) {\r\n        this.data = data;\r\n        this.expires = new Date(typeof expiryTime === 'number' ? expiryTime : 0);\r\n    }\r\n    Object.defineProperty(CachedItemImpl.prototype, \"expired\", {\r\n        get: function () {\r\n            return this.expiresIn === 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CachedItemImpl.prototype, \"expiresIn\", {\r\n        get: function () {\r\n            return Math.max(0, this.expires.getTime() - Date.now());\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CachedItemImpl.prototype, \"hasData\", {\r\n        get: function () {\r\n            return this.data !== null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    CachedItemImpl.prototype.toJSON = function () {\r\n        return {\r\n            data: this.data,\r\n            expired: this.expired,\r\n            expires: this.expires,\r\n            expiresIn: this.expiresIn,\r\n            hasData: this.hasData\r\n        };\r\n    };\r\n    tslib_1.__decorate([\r\n        LazyGetter(),\r\n        tslib_1.__metadata(\"design:type\", Boolean),\r\n        tslib_1.__metadata(\"design:paramtypes\", [])\r\n    ], CachedItemImpl.prototype, \"expired\", null);\r\n    tslib_1.__decorate([\r\n        LazyGetter(),\r\n        tslib_1.__metadata(\"design:type\", Number),\r\n        tslib_1.__metadata(\"design:paramtypes\", [])\r\n    ], CachedItemImpl.prototype, \"expiresIn\", null);\r\n    tslib_1.__decorate([\r\n        LazyGetter(),\r\n        tslib_1.__metadata(\"design:type\", Boolean),\r\n        tslib_1.__metadata(\"design:paramtypes\", [])\r\n    ], CachedItemImpl.prototype, \"hasData\", null);\r\n    return CachedItemImpl;\r\n}());\r\nexport { CachedItemImpl };\r\naddToStringTag(CachedItemImpl, 'CachedItem');\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/NgForage/cache/CachedItemImpl.ts\n// module id = 12\n// module chunks = 0 1","/**\n * Evaluate the getter function and cache the result\n * @param {boolean} [setProto=false] Set the value on the class prototype as well. Only applies to non-static getters.\n * @param {boolean} [makeNonConfigurable=false] Set to true to make the resolved property non-configurable\n * @return {(target: any, key: string, descriptor: PropertyDescriptor) => void} A Typescript decorator function\n */\nexport function LazyGetter(setProto, makeNonConfigurable) {\n    if (setProto === void 0) { setProto = false; }\n    if (makeNonConfigurable === void 0) { makeNonConfigurable = false; }\n    return function (target, key, descriptor) {\n        if (!descriptor) {\n            descriptor = Object.getOwnPropertyDescriptor(target, key);\n        }\n        var originalMethod = descriptor.get;\n        if (!originalMethod) {\n            throw new Error('@LazyGetter can only decorate getters!');\n        }\n        else if (!descriptor.configurable) {\n            throw new Error('@LazyGetter target must be configurable');\n        }\n        else {\n            descriptor.get = function () {\n                var value = originalMethod.apply(this, arguments);\n                var newDescriptor = {\n                    configurable: !makeNonConfigurable,\n                    enumerable: descriptor.enumerable,\n                    value: value\n                };\n                var isStatic = Object.getPrototypeOf(target) === Function.prototype;\n                if (isStatic || setProto) {\n                    Object.defineProperty(target, key, newDescriptor);\n                }\n                if (!isStatic) {\n                    Object.defineProperty(this, key, newDescriptor);\n                }\n                return value;\n            };\n        }\n    };\n}\n//# sourceMappingURL=LazyGetter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/typescript-lazy-get-decorator/dist/esm5/LazyGetter.js\n// module id = 13\n// module chunks = 0 1"],"sourceRoot":""}