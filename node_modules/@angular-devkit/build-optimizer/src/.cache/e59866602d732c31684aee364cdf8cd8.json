{"remainingRequest":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular/material/esm5/tooltip.es5.js","dependencies":[{"path":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular/material/esm5/tooltip.es5.js","mtime":1507246791000},{"path":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_cdk_a11y,_angular_cdk_overlay,_angular_cdk_platform,_angular_common,_angular_core,_angular_material_core,_angular_animations,_angular_cdk_bidi,_angular_cdk_coercion,_angular_cdk_keycodes,_angular_cdk_portal,_angular_cdk_rxjs,_angular_cdk_scrolling,rxjs_Subject PURE_IMPORTS_END */\nimport { A11yModule, ARIA_DESCRIBER_PROVIDER, AriaDescriber } from '@angular/cdk/a11y';\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform, PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, ElementRef, Inject, InjectionToken, Input, NgModule, NgZone, Optional, Renderer2, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { MatCommonModule } from '@angular/material/core';\nimport { animate, state, style, transition, trigger } from '@angular/animations';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { ComponentPortal } from '@angular/cdk/portal';\nimport { first } from '@angular/cdk/rxjs';\nimport { ScrollDispatcher } from '@angular/cdk/scrolling';\nimport { Subject } from 'rxjs/Subject';\n/**\n * Time in ms to delay before changing the tooltip visibility to hidden\n */\nvar TOUCHEND_HIDE_DELAY = 1500;\n/**\n * Time in ms to throttle repositioning after scroll events.\n */\nvar SCROLL_THROTTLE_MS = 20;\n/**\n * CSS class that will be attached to the overlay panel.\n */\nvar TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @param {?} position\n * @return {?}\n */\nfunction getMatTooltipInvalidPositionError(position) {\n    return Error(\"Tooltip position \\\"\" + position + \"\\\" is invalid.\");\n}\n/**\n * Injection token that determines the scroll handling while a tooltip is visible.\n */\nvar MAT_TOOLTIP_SCROLL_STRATEGY = /*@__PURE__*/ new InjectionToken('mat-tooltip-scroll-strategy');\n/**\n * \\@docs-private\n * @param {?} overlay\n * @return {?}\n */\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return function () { return overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS }); };\n}\n/**\n * \\@docs-private\n */\nvar MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY\n};\n/**\n * Directive that attaches a material design tooltip to the host element. Animates the showing and\n * hiding of a tooltip provided position (defaults to below the element).\n *\n * https://material.google.com/components/tooltips.html\n */\nvar MatTooltip = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} renderer\n     * @param {?} _overlay\n     * @param {?} _elementRef\n     * @param {?} _scrollDispatcher\n     * @param {?} _viewContainerRef\n     * @param {?} _ngZone\n     * @param {?} _platform\n     * @param {?} _ariaDescriber\n     * @param {?} _scrollStrategy\n     * @param {?} _dir\n     */\n    function MatTooltip(renderer, _overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _scrollStrategy, _dir) {\n        var _this = this;\n        this._overlay = _overlay;\n        this._elementRef = _elementRef;\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewContainerRef = _viewContainerRef;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        this._ariaDescriber = _ariaDescriber;\n        this._scrollStrategy = _scrollStrategy;\n        this._dir = _dir;\n        this._position = 'below';\n        this._disabled = false;\n        /**\n         * The default delay in ms before showing the tooltip after show is called\n         */\n        this.showDelay = 0;\n        /**\n         * The default delay in ms before hiding the tooltip after hide is called\n         */\n        this.hideDelay = 0;\n        this._message = '';\n        // The mouse events shouldn't be bound on iOS devices, because\n        // they can prevent the first tap from firing its click event.\n        if (!_platform.IOS) {\n            this._enterListener =\n                renderer.listen(_elementRef.nativeElement, 'mouseenter', function () { return _this.show(); });\n            this._leaveListener =\n                renderer.listen(_elementRef.nativeElement, 'mouseleave', function () { return _this.hide(); });\n        }\n    }\n    Object.defineProperty(MatTooltip.prototype, \"position\", {\n        /**\n         * Allows the user to define the position of the tooltip relative to the parent element\n         * @return {?}\n         */\n        get: function () { return this._position; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            if (value !== this._position) {\n                this._position = value;\n                // TODO(andrewjs): When the overlay's position can be dynamically changed, do not destroy\n                // the tooltip.\n                if (this._tooltipInstance) {\n                    this._disposeTooltip();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"disabled\", {\n        /**\n         * Disables the display of the tooltip.\n         * @return {?}\n         */\n        get: function () { return this._disabled; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._disabled = coerceBooleanProperty(value);\n            // If tooltip is disabled, hide immediately.\n            if (this._disabled) {\n                this.hide(0);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"_positionDeprecated\", {\n        /**\n         * @deprecated\n         * @return {?}\n         */\n        get: function () { return this._position; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this._position = value; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"message\", {\n        /**\n         * The message to be displayed in the tooltip\n         * @return {?}\n         */\n        get: function () { return this._message; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\n            // If the message is not a string (e.g. number), convert it to a string and trim it.\n            this._message = value != null ? (\"\" + value).trim() : '';\n            this._updateTooltipMessage();\n            this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatTooltip.prototype, \"tooltipClass\", {\n        /**\n         * Classes to be passed to the tooltip. Supports the same syntax as `ngClass`.\n         * @return {?}\n         */\n        get: function () { return this._tooltipClass; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._tooltipClass = value;\n            if (this._tooltipInstance) {\n                this._setTooltipClass(this._tooltipClass);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Dispose the tooltip when destroyed.\n     * @return {?}\n     */\n    MatTooltip.prototype.ngOnDestroy = function () {\n        if (this._tooltipInstance) {\n            this._disposeTooltip();\n        }\n        // Clean up the event listeners set in the constructor\n        if (!this._platform.IOS) {\n            this._enterListener();\n            this._leaveListener();\n        }\n        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);\n    };\n    /**\n     * Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n    MatTooltip.prototype.show = function (delay) {\n        if (delay === void 0) {\n            delay = this.showDelay;\n        }\n        if (this.disabled || !this.message) {\n            return;\n        }\n        if (!this._tooltipInstance) {\n            this._createTooltip();\n        }\n        this._setTooltipClass(this._tooltipClass);\n        this._updateTooltipMessage(); /** @type {?} */\n        ((this._tooltipInstance)).show(this._position, delay);\n    };\n    /**\n     * Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input\n     * @param {?=} delay\n     * @return {?}\n     */\n    MatTooltip.prototype.hide = function (delay) {\n        if (delay === void 0) {\n            delay = this.hideDelay;\n        }\n        if (this._tooltipInstance) {\n            this._tooltipInstance.hide(delay);\n        }\n    };\n    /**\n     * Shows/hides the tooltip\n     * @return {?}\n     */\n    MatTooltip.prototype.toggle = function () {\n        this._isTooltipVisible() ? this.hide() : this.show();\n    };\n    /**\n     * Returns true if the tooltip is currently visible to the user\n     * @return {?}\n     */\n    MatTooltip.prototype._isTooltipVisible = function () {\n        return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n    };\n    /**\n     * Handles the keydown events on the host element.\n     * @param {?} e\n     * @return {?}\n     */\n    MatTooltip.prototype._handleKeydown = function (e) {\n        if (this._isTooltipVisible() && e.keyCode === ESCAPE) {\n            e.stopPropagation();\n            this.hide(0);\n        }\n    };\n    /**\n     * Create the tooltip to display\n     * @return {?}\n     */\n    MatTooltip.prototype._createTooltip = function () {\n        var _this = this;\n        var /** @type {?} */ overlayRef = this._createOverlay();\n        var /** @type {?} */ portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);\n        this._tooltipInstance = overlayRef.attach(portal).instance; /** @type {?} */\n        ((\n        // Dispose the overlay when finished the shown tooltip.\n        this._tooltipInstance)).afterHidden().subscribe(function () {\n            // Check first if the tooltip has already been removed through this components destroy.\n            if (_this._tooltipInstance) {\n                _this._disposeTooltip();\n            }\n        });\n    };\n    /**\n     * Create the overlay config and position strategy\n     * @return {?}\n     */\n    MatTooltip.prototype._createOverlay = function () {\n        var _this = this;\n        var /** @type {?} */ origin = this._getOrigin();\n        var /** @type {?} */ overlay = this._getOverlayPosition();\n        // Create connected position strategy that listens for scroll events to reposition.\n        var /** @type {?} */ strategy = this._overlay\n            .position()\n            .connectedTo(this._elementRef, origin.main, overlay.main)\n            .withFallbackPosition(origin.fallback, overlay.fallback);\n        strategy.withScrollableContainers(this._scrollDispatcher.getScrollContainers(this._elementRef));\n        strategy.onPositionChange.subscribe(function (change) {\n            if (_this._tooltipInstance) {\n                if (change.scrollableViewProperties.isOverlayClipped && _this._tooltipInstance.isVisible()) {\n                    // After position changes occur and the overlay is clipped by\n                    // a parent scrollable then close the tooltip.\n                    _this.hide(0);\n                }\n                else {\n                    // Otherwise recalculate the origin based on the new position.\n                    _this._tooltipInstance._setTransformOrigin(change.connectionPair);\n                }\n            }\n        });\n        var /** @type {?} */ config = new OverlayConfig({\n            direction: this._dir ? this._dir.value : 'ltr',\n            positionStrategy: strategy,\n            panelClass: TOOLTIP_PANEL_CLASS,\n            scrollStrategy: this._scrollStrategy()\n        });\n        this._overlayRef = this._overlay.create(config);\n        return this._overlayRef;\n    };\n    /**\n     * Disposes the current tooltip and the overlay it is attached to\n     * @return {?}\n     */\n    MatTooltip.prototype._disposeTooltip = function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n        this._tooltipInstance = null;\n    };\n    /**\n     * Returns the origin position and a fallback position based on the user's position preference.\n     * The fallback position is the inverse of the origin (e.g. 'below' -> 'above').\n     * @return {?}\n     */\n    MatTooltip.prototype._getOrigin = function () {\n        var /** @type {?} */ isDirectionLtr = !this._dir || this._dir.value == 'ltr';\n        var /** @type {?} */ position;\n        if (this.position == 'above' || this.position == 'below') {\n            position = { originX: 'center', originY: this.position == 'above' ? 'top' : 'bottom' };\n        }\n        else if (this.position == 'left' ||\n            this.position == 'before' && isDirectionLtr ||\n            this.position == 'after' && !isDirectionLtr) {\n            position = { originX: 'start', originY: 'center' };\n        }\n        else if (this.position == 'right' ||\n            this.position == 'after' && isDirectionLtr ||\n            this.position == 'before' && !isDirectionLtr) {\n            position = { originX: 'end', originY: 'center' };\n        }\n        else {\n            throw getMatTooltipInvalidPositionError(this.position);\n        }\n        var _a = this._invertPosition(position.originX, position.originY), x = _a.x, y = _a.y;\n        return {\n            main: position,\n            fallback: { originX: x, originY: y }\n        };\n    };\n    /**\n     * Returns the overlay position and a fallback position based on the user's preference\n     * @return {?}\n     */\n    MatTooltip.prototype._getOverlayPosition = function () {\n        var /** @type {?} */ isLtr = !this._dir || this._dir.value == 'ltr';\n        var /** @type {?} */ position;\n        if (this.position == 'above') {\n            position = { overlayX: 'center', overlayY: 'bottom' };\n        }\n        else if (this.position == 'below') {\n            position = { overlayX: 'center', overlayY: 'top' };\n        }\n        else if (this.position == 'left' ||\n            this.position == 'before' && isLtr ||\n            this.position == 'after' && !isLtr) {\n            position = { overlayX: 'end', overlayY: 'center' };\n        }\n        else if (this.position == 'right' ||\n            this.position == 'after' && isLtr ||\n            this.position == 'before' && !isLtr) {\n            position = { overlayX: 'start', overlayY: 'center' };\n        }\n        else {\n            throw getMatTooltipInvalidPositionError(this.position);\n        }\n        var _a = this._invertPosition(position.overlayX, position.overlayY), x = _a.x, y = _a.y;\n        return {\n            main: position,\n            fallback: { overlayX: x, overlayY: y }\n        };\n    };\n    /**\n     * Updates the tooltip message and repositions the overlay according to the new message length\n     * @return {?}\n     */\n    MatTooltip.prototype._updateTooltipMessage = function () {\n        var _this = this;\n        // Must wait for the message to be painted to the tooltip so that the overlay can properly\n        // calculate the correct positioning based on the size of the text.\n        if (this._tooltipInstance) {\n            this._tooltipInstance.message = this.message;\n            this._tooltipInstance._markForCheck();\n            first.call(this._ngZone.onMicrotaskEmpty.asObservable()).subscribe(function () {\n                if (_this._tooltipInstance) {\n                    ((_this._overlayRef)).updatePosition();\n                }\n            });\n        }\n    };\n    /**\n     * Updates the tooltip class\n     * @param {?} tooltipClass\n     * @return {?}\n     */\n    MatTooltip.prototype._setTooltipClass = function (tooltipClass) {\n        if (this._tooltipInstance) {\n            this._tooltipInstance.tooltipClass = tooltipClass;\n            this._tooltipInstance._markForCheck();\n        }\n    };\n    /**\n     * Inverts an overlay position.\n     * @param {?} x\n     * @param {?} y\n     * @return {?}\n     */\n    MatTooltip.prototype._invertPosition = function (x, y) {\n        if (this.position === 'above' || this.position === 'below') {\n            if (y === 'top') {\n                y = 'bottom';\n            }\n            else if (y === 'bottom') {\n                y = 'top';\n            }\n        }\n        else {\n            if (x === 'end') {\n                x = 'start';\n            }\n            else if (x === 'start') {\n                x = 'end';\n            }\n        }\n        return { x: x, y: y };\n    };\n    return MatTooltip;\n}());\n/**\n * Internal component that wraps the tooltip's content.\n * \\@docs-private\n */\nvar TooltipComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _changeDetectorRef\n     */\n    function TooltipComponent(_changeDetectorRef) {\n        this._changeDetectorRef = _changeDetectorRef;\n        /**\n         * Property watched by the animation framework to show or hide the tooltip\n         */\n        this._visibility = 'initial';\n        /**\n         * Whether interactions on the page should close the tooltip\n         */\n        this._closeOnInteraction = false;\n        /**\n         * The transform origin used in the animation for showing and hiding the tooltip\n         */\n        this._transformOrigin = 'bottom';\n        /**\n         * Subject for notifying that the tooltip has been hidden from the view\n         */\n        this._onHide = new Subject();\n    }\n    /**\n     * Shows the tooltip with an animation originating from the provided origin\n     * @param {?} position Position of the tooltip.\n     * @param {?} delay Amount of milliseconds to the delay showing the tooltip.\n     * @return {?}\n     */\n    TooltipComponent.prototype.show = function (position, delay) {\n        var _this = this;\n        // Cancel the delayed hide if it is scheduled\n        if (this._hideTimeoutId) {\n            clearTimeout(this._hideTimeoutId);\n        }\n        // Body interactions should cancel the tooltip if there is a delay in showing.\n        this._closeOnInteraction = true;\n        this._position = position;\n        this._showTimeoutId = setTimeout(function () {\n            _this._visibility = 'visible';\n            // Mark for check so if any parent component has set the\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\n            _this._markForCheck();\n        }, delay);\n    };\n    /**\n     * Begins the animation to hide the tooltip after the provided delay in ms.\n     * @param {?} delay Amount of milliseconds to delay showing the tooltip.\n     * @return {?}\n     */\n    TooltipComponent.prototype.hide = function (delay) {\n        var _this = this;\n        // Cancel the delayed show if it is scheduled\n        if (this._showTimeoutId) {\n            clearTimeout(this._showTimeoutId);\n        }\n        this._hideTimeoutId = setTimeout(function () {\n            _this._visibility = 'hidden';\n            // Mark for check so if any parent component has set the\n            // ChangeDetectionStrategy to OnPush it will be checked anyways\n            _this._markForCheck();\n        }, delay);\n    };\n    /**\n     * Returns an observable that notifies when the tooltip has been hidden from view.\n     * @return {?}\n     */\n    TooltipComponent.prototype.afterHidden = function () {\n        return this._onHide.asObservable();\n    };\n    /**\n     * Whether the tooltip is being displayed.\n     * @return {?}\n     */\n    TooltipComponent.prototype.isVisible = function () {\n        return this._visibility === 'visible';\n    };\n    /**\n     * Sets the tooltip transform origin according to the position of the tooltip overlay.\n     * @param {?} overlayPosition\n     * @return {?}\n     */\n    TooltipComponent.prototype._setTransformOrigin = function (overlayPosition) {\n        var /** @type {?} */ axis = (this._position === 'above' || this._position === 'below') ? 'Y' : 'X';\n        var /** @type {?} */ position = axis == 'X' ? overlayPosition.overlayX : overlayPosition.overlayY;\n        if (position === 'top' || position === 'bottom') {\n            this._transformOrigin = position;\n        }\n        else if (position === 'start') {\n            this._transformOrigin = 'left';\n        }\n        else if (position === 'end') {\n            this._transformOrigin = 'right';\n        }\n        else {\n            throw getMatTooltipInvalidPositionError(this._position);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    TooltipComponent.prototype._animationStart = function () {\n        this._closeOnInteraction = false;\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    TooltipComponent.prototype._animationDone = function (event) {\n        var _this = this;\n        var /** @type {?} */ toState = (event.toState);\n        if (toState === 'hidden' && !this.isVisible()) {\n            this._onHide.next();\n        }\n        if (toState === 'visible' || toState === 'hidden') {\n            // Note: as of Angular 4.3, the animations module seems to fire the `start` callback before\n            // the end if animations are disabled. Make this call async to ensure that it still fires\n            // at the appropriate time.\n            Promise.resolve().then(function () { return _this._closeOnInteraction = true; });\n        }\n    };\n    /**\n     * Interactions on the HTML body should close the tooltip immediately as defined in the\n     * material design spec.\n     * https://material.google.com/components/tooltips.html#tooltips-interaction\n     * @return {?}\n     */\n    TooltipComponent.prototype._handleBodyInteraction = function () {\n        if (this._closeOnInteraction) {\n            this.hide(0);\n        }\n    };\n    /**\n     * Marks that the tooltip needs to be checked in the next change detection run.\n     * Mainly used for rendering the initial text before positioning a tooltip, which\n     * can be problematic in components with OnPush change detection.\n     * @return {?}\n     */\n    TooltipComponent.prototype._markForCheck = function () {\n        this._changeDetectorRef.markForCheck();\n    };\n    return TooltipComponent;\n}());\nvar MatTooltipModule = /*@__PURE__*/ (function () {\n    function MatTooltipModule() {\n    }\n    return MatTooltipModule;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatTooltipModule, TOUCHEND_HIDE_DELAY, SCROLL_THROTTLE_MS, TOOLTIP_PANEL_CLASS, getMatTooltipInvalidPositionError, MAT_TOOLTIP_SCROLL_STRATEGY, MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY, MAT_TOOLTIP_SCROLL_STRATEGY_PROVIDER, MatTooltip, TooltipComponent };\n//# sourceMappingURL=tooltip.es5.js.map\n",null]}