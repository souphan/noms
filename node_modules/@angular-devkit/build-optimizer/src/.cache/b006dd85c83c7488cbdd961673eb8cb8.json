{"remainingRequest":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular/material/esm5/chips.es5.js","dependencies":[{"path":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular/material/esm5/chips.es5.js","mtime":1507246791000},{"path":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/souphan/Library/Mobile Documents/com~apple~CloudDocs/nomfoods/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1518048966000}],"contextDependencies":[],"result":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** PURE_IMPORTS_START _angular_core,_angular_cdk_a11y,_angular_cdk_bidi,_angular_cdk_coercion,_angular_cdk_collections,_angular_cdk_keycodes,_angular_cdk_rxjs,_angular_forms,_angular_material_form_field,rxjs_observable_merge,rxjs_Subject,rxjs_Subscription,tslib,tslib,_angular_material_core PURE_IMPORTS_END */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, EventEmitter, Input, NgModule, Optional, Output, Renderer2, Self, ViewEncapsulation } from '@angular/core';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { BACKSPACE, DELETE, ENTER, LEFT_ARROW, RIGHT_ARROW, SPACE } from '@angular/cdk/keycodes';\nimport { startWith } from '@angular/cdk/rxjs';\nimport { FormGroupDirective, NgControl, NgForm } from '@angular/forms';\nimport { MatFormFieldControl } from '@angular/material/form-field';\nimport { merge } from 'rxjs/observable/merge';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { __extends } from 'tslib';\nimport { mixinColor, mixinDisabled } from '@angular/material/core';\n/**\n * Event object emitted by MatChip when selected or deselected.\n */\nvar MatChipSelectionChange = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} source\n     * @param {?} selected\n     * @param {?=} isUserInput\n     */\n    function MatChipSelectionChange(source, selected, isUserInput) {\n        if (isUserInput === void 0) {\n            isUserInput = false;\n        }\n        this.source = source;\n        this.selected = selected;\n        this.isUserInput = isUserInput;\n    }\n    return MatChipSelectionChange;\n}());\n/**\n * \\@docs-private\n */\nvar MatChipBase = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _renderer\n     * @param {?} _elementRef\n     */\n    function MatChipBase(_renderer, _elementRef) {\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n    }\n    return MatChipBase;\n}());\nvar _MatChipMixinBase = /*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisabled(MatChipBase), 'primary');\n/**\n * Dummy directive to add CSS class to basic chips.\n * \\@docs-private\n */\nvar MatBasicChip = /*@__PURE__*/ (function () {\n    function MatBasicChip() {\n    }\n    return MatBasicChip;\n}());\n/**\n * Material design styled Chip component. Used inside the MatChipList component.\n */\nvar MatChip = /*@__PURE__*/ (function (_super) {\n    __extends(MatChip, _super);\n    /**\n     * @param {?} renderer\n     * @param {?} _elementRef\n     */\n    function MatChip(renderer, _elementRef) {\n        var _this = _super.call(this, renderer, _elementRef) || this;\n        _this._elementRef = _elementRef;\n        _this._selected = false;\n        _this._selectable = true;\n        _this._removable = true;\n        /**\n         * Whether the chip has focus.\n         */\n        _this._hasFocus = false;\n        /**\n         * Emits when the chip is focused.\n         */\n        _this._onFocus = new Subject();\n        /**\n         * Emits when the chip is blured.\n         */\n        _this._onBlur = new Subject();\n        /**\n         * Emitted when the chip is selected or deselected.\n         */\n        _this.selectionChange = new EventEmitter();\n        /**\n         * Emitted when the chip is destroyed.\n         */\n        _this.destroyed = new EventEmitter();\n        /**\n         * Emitted when the chip is destroyed.\n         * @deprecated Use 'destroyed' instead.\n         */\n        _this.destroy = _this.destroyed;\n        /**\n         * Emitted when a chip is to be removed.\n         */\n        _this.removed = new EventEmitter();\n        /**\n         * Emitted when a chip is to be removed.\n         * @deprecated Use `removed` instead.\n         */\n        _this.onRemove = _this.removed;\n        return _this;\n    }\n    Object.defineProperty(MatChip.prototype, \"selected\", {\n        /**\n         * Whether the chip is selected.\n         * @return {?}\n         */\n        get: function () {\n            return this._selected;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._selected = coerceBooleanProperty(value);\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: false,\n                selected: value\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"value\", {\n        /**\n         * The value of the chip. Defaults to the content inside <mat-chip> tags.\n         * @return {?}\n         */\n        get: function () {\n            return this._value != undefined\n                ? this._value\n                : this._elementRef.nativeElement.textContent;\n        },\n        /**\n         * @param {?} newValue\n         * @return {?}\n         */\n        set: function (newValue) {\n            this._value = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"selectable\", {\n        /**\n         * Whether or not the chips are selectable. When a chip is not selectable,\n         * changes to it's selected state are always ignored.\n         * @return {?}\n         */\n        get: function () {\n            return this._selectable;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._selectable = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"removable\", {\n        /**\n         * Determines whether or not the chip displays the remove styling and emits (remove) events.\n         * @return {?}\n         */\n        get: function () {\n            return this._removable;\n        },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._removable = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChip.prototype, \"ariaSelected\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this.selectable ? this.selected.toString() : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatChip.prototype.ngOnDestroy = function () {\n        this.destroyed.emit({ chip: this });\n    };\n    /**\n     * Selects the chip.\n     * @return {?}\n     */\n    MatChip.prototype.select = function () {\n        this._selected = true;\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: false,\n            selected: true\n        });\n    };\n    /**\n     * Deselects the chip.\n     * @return {?}\n     */\n    MatChip.prototype.deselect = function () {\n        this._selected = false;\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: false,\n            selected: false\n        });\n    };\n    /**\n     * Select this chip and emit selected event\n     * @return {?}\n     */\n    MatChip.prototype.selectViaInteraction = function () {\n        this._selected = true;\n        // Emit select event when selected changes.\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: true,\n            selected: true\n        });\n    };\n    /**\n     * Toggles the current selected state of this chip.\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatChip.prototype.toggleSelected = function (isUserInput) {\n        if (isUserInput === void 0) {\n            isUserInput = false;\n        }\n        this._selected = !this.selected;\n        this.selectionChange.emit({\n            source: this,\n            isUserInput: isUserInput,\n            selected: this._selected\n        });\n        return this.selected;\n    };\n    /**\n     * Allows for programmatic focusing of the chip.\n     * @return {?}\n     */\n    MatChip.prototype.focus = function () {\n        this._elementRef.nativeElement.focus();\n        this._onFocus.next({ chip: this });\n    };\n    /**\n     * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n     * @return {?}\n     */\n    MatChip.prototype.remove = function () {\n        if (this.removable) {\n            this.removed.emit({ chip: this });\n        }\n    };\n    /**\n     * Ensures events fire properly upon click.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChip.prototype._handleClick = function (event) {\n        // Check disabled\n        if (this.disabled) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        this.focus();\n    };\n    /**\n     * Handle custom key presses.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChip.prototype._handleKeydown = function (event) {\n        if (this.disabled) {\n            return;\n        }\n        switch (event.keyCode) {\n            case DELETE:\n            case BACKSPACE:\n                // If we are removable, remove the focused chip\n                this.remove();\n                // Always prevent so page navigation does not occur\n                event.preventDefault();\n                break;\n            case SPACE:\n                // If we are selectable, toggle the focused chip\n                if (this.selectable) {\n                    this.toggleSelected(true);\n                }\n                // Always prevent space from scrolling the page since the list has focus\n                event.preventDefault();\n                break;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatChip.prototype._blur = function () {\n        this._hasFocus = false;\n        this._onBlur.next({ chip: this });\n    };\n    return MatChip;\n}(_MatChipMixinBase));\n/**\n * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n * available at https://material.io/icons/#ic_cancel.\n *\n * Example:\n *\n *     <mat-chip>\n *       <mat-icon matChipRemove>cancel</mat-icon>\n *     </mat-chip>\n *\n * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n * styles to properly center the icon within the chip.\n */\nvar MatChipRemove = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _parentChip\n     */\n    function MatChipRemove(_parentChip) {\n        this._parentChip = _parentChip;\n    }\n    /**\n     * Calls the parent chip's public `remove()` method if applicable.\n     * @return {?}\n     */\n    MatChipRemove.prototype._handleClick = function () {\n        if (this._parentChip.removable) {\n            this._parentChip.remove();\n        }\n    };\n    return MatChipRemove;\n}());\n// Increasing integer for generating unique ids for chip-list components.\nvar nextUniqueId = 0;\n/**\n * Change event object that is emitted when the chip list value has changed.\n */\nvar MatChipListChange = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} source\n     * @param {?} value\n     */\n    function MatChipListChange(source, value) {\n        this.source = source;\n        this.value = value;\n    }\n    return MatChipListChange;\n}());\n/**\n * A material design chips component (named ChipList for it's similarity to the List component).\n */\nvar MatChipList = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _renderer\n     * @param {?} _elementRef\n     * @param {?} _changeDetectorRef\n     * @param {?} _dir\n     * @param {?} _parentForm\n     * @param {?} _parentFormGroup\n     * @param {?} ngControl\n     */\n    function MatChipList(_renderer, _elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, ngControl) {\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n        this.controlType = 'mat-chip-list';\n        /**\n         * Stream that emits whenever the state of the input changes such that the wrapping `MatFormField`\n         * needs to run change detection.\n         */\n        this.stateChanges = new Subject();\n        /**\n         * When a chip is destroyed, we track the index so we can focus the appropriate next chip.\n         */\n        this._lastDestroyedIndex = null;\n        /**\n         * Track which chips we're listening to for focus/destruction.\n         */\n        this._chipSet = new WeakMap();\n        /**\n         * Subscription to tabbing out from the chip list.\n         */\n        this._tabOutSubscription = Subscription.EMPTY;\n        /**\n         * Whether or not the chip is selectable.\n         */\n        this._selectable = true;\n        /**\n         * Whether the component is in multiple selection mode.\n         */\n        this._multiple = false;\n        /**\n         * Uid of the chip list\n         */\n        this._uid = \"mat-chip-list-\" + nextUniqueId++;\n        /**\n         * Whether this is required\n         */\n        this._required = false;\n        /**\n         * Whether this is disabled\n         */\n        this._disabled = false;\n        /**\n         * Tab index for the chip list.\n         */\n        this._tabIndex = 0;\n        /**\n         * User defined tab index.\n         * When it is not null, use user defined tab index. Otherwise use _tabIndex\n         */\n        this._userTabIndex = null;\n        /**\n         * Function when touched\n         */\n        this._onTouched = function () { };\n        /**\n         * Function when changed\n         */\n        this._onChange = function () { };\n        /**\n         * Comparison function to specify which option is displayed. Defaults to object equality.\n         */\n        this._compareWith = function (o1, o2) { return o1 === o2; };\n        /**\n         * Orientation of the chip list.\n         */\n        this.ariaOrientation = 'horizontal';\n        /**\n         * Event emitted when the selected chip list value has been changed by the user.\n         */\n        this.change = new EventEmitter();\n        /**\n         * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n         * to facilitate the two-way binding for the `value` input.\n         * \\@docs-private\n         */\n        this.valueChange = new EventEmitter();\n        if (this.ngControl) {\n            this.ngControl.valueAccessor = this;\n        }\n    }\n    Object.defineProperty(MatChipList.prototype, \"selected\", {\n        /**\n         * The array of selected chips inside chip list.\n         * @return {?}\n         */\n        get: function () {\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"multiple\", {\n        /**\n         * Whether the user should be allowed to select multiple chips.\n         * @return {?}\n         */\n        get: function () { return this._multiple; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._multiple = coerceBooleanProperty(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"compareWith\", {\n        /**\n         * A function to compare the option values with the selected values. The first argument\n         * is a value from an option. The second is a value from the selection. A boolean\n         * should be returned.\n         * @return {?}\n         */\n        get: function () { return this._compareWith; },\n        /**\n         * @param {?} fn\n         * @return {?}\n         */\n        set: function (fn) {\n            this._compareWith = fn;\n            if (this._selectionModel) {\n                // A different comparator means the selection could change.\n                this._initializeSelection();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"value\", {\n        /**\n         * Required for FormFieldControl\n         * @return {?}\n         */\n        get: function () { return this._value; },\n        /**\n         * @param {?} newValue\n         * @return {?}\n         */\n        set: function (newValue) {\n            this.writeValue(newValue);\n            this._value = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"id\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._id || this._uid; },\n        /**\n         * Required for FormFieldControl. The ID of the chip list\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._id = value;\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"required\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._required;\n        },\n        /**\n         * Required for FormFieldControl. Whether the chip list is required.\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._required = coerceBooleanProperty(value);\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"placeholder\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n        },\n        /**\n         * For FormFieldControl. Use chip input's placholder if there's a chip input\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._placeholder = value;\n            this.stateChanges.next();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"focused\", {\n        /**\n         * Whether any chips or the matChipInput inside of this chip-list has focus.\n         * @return {?}\n         */\n        get: function () {\n            return this.chips.some(function (chip) { return chip._hasFocus; }) ||\n                (this._chipInput && this._chipInput.focused);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"empty\", {\n        /**\n         * Whether this chip-list contains no chips and no matChipInput.\n         * @return {?}\n         */\n        get: function () {\n            return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"shouldPlaceholderFloat\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this.empty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"disabled\", {\n        /**\n         * Whether this chip-list is disabled.\n         * @return {?}\n         */\n        get: function () { return this.ngControl ? this.ngControl.disabled : this._disabled; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this._disabled = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"errorState\", {\n        /**\n         * Whether the chip list is in an error state.\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ isInvalid = this.ngControl && this.ngControl.invalid;\n            var /** @type {?} */ isTouched = this.ngControl && this.ngControl.touched;\n            var /** @type {?} */ isSubmitted = (this._parentFormGroup && this._parentFormGroup.submitted) ||\n                (this._parentForm && this._parentForm.submitted);\n            return !!(isInvalid && (isTouched || isSubmitted));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"selectable\", {\n        /**\n         * Whether or not this chip is selectable. When a chip is not selectable,\n         * its selected state is always ignored.\n         * @return {?}\n         */\n        get: function () { return this._selectable; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this._selectable = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"tabIndex\", {\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            this._userTabIndex = value;\n            this._tabIndex = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipSelectionChanges\", {\n        /**\n         * Combined stream of all of the child chips' selection change events.\n         * @return {?}\n         */\n        get: function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip.selectionChange; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipFocusChanges\", {\n        /**\n         * Combined stream of all of the child chips' focus change events.\n         * @return {?}\n         */\n        get: function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip._onFocus; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipBlurChanges\", {\n        /**\n         * Combined stream of all of the child chips' blur change events.\n         * @return {?}\n         */\n        get: function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip._onBlur; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipList.prototype, \"chipRemoveChanges\", {\n        /**\n         * Combined stream of all of the child chips' remove change events.\n         * @return {?}\n         */\n        get: function () {\n            return merge.apply(void 0, this.chips.map(function (chip) { return chip.destroy; }));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        this._keyManager = new FocusKeyManager(this.chips).withWrap();\n        // Prevents the chip list from capturing focus and redirecting\n        // it back to the first chip when the user tabs out.\n        this._tabOutSubscription = this._keyManager.tabOut.subscribe(function () {\n            _this._tabIndex = -1;\n            setTimeout(function () { return _this._tabIndex = _this._userTabIndex || 0; });\n        });\n        // When the list changes, re-subscribe\n        this._changeSubscription = startWith.call(this.chips.changes, null).subscribe(function () {\n            _this._resetChips();\n            // Reset chips selected/deselected status\n            _this._initializeSelection();\n            // Check to see if we need to update our tab index\n            _this._updateTabIndex();\n            // Check to see if we have a destroyed chip and need to refocus\n            _this._updateFocusForDestroyedChips();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngOnInit = function () {\n        this._selectionModel = new SelectionModel(this.multiple, undefined, false);\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.ngOnDestroy = function () {\n        this._tabOutSubscription.unsubscribe();\n        if (this._changeSubscription) {\n            this._changeSubscription.unsubscribe();\n        }\n        this._dropSubscriptions();\n    };\n    /**\n     * Associates an HTML input element with this chip list.\n     * @param {?} inputElement\n     * @return {?}\n     */\n    MatChipList.prototype.registerInput = function (inputElement) {\n        this._chipInput = inputElement;\n    };\n    /**\n     * @param {?} ids\n     * @return {?}\n     */\n    MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    MatChipList.prototype.writeValue = function (value) {\n        if (this.chips) {\n            this._setSelectionByValue(value, false);\n        }\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatChipList.prototype.registerOnChange = function (fn) {\n        this._onChange = fn;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    MatChipList.prototype.registerOnTouched = function (fn) {\n        this._onTouched = fn;\n    };\n    /**\n     * @param {?} disabled\n     * @return {?}\n     */\n    MatChipList.prototype.setDisabledState = function (disabled) {\n        this.disabled = disabled;\n        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', disabled);\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype.onContainerClick = function () {\n        this.focus();\n    };\n    /**\n     * Focuses the the first non-disabled chip in this chip list, or the associated input when there\n     * are no eligible chips.\n     * @return {?}\n     */\n    MatChipList.prototype.focus = function () {\n        // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n        // Focus on first element if there's no chipInput inside chip-list\n        if (this._chipInput && this._chipInput.focused) {\n            // do nothing\n        }\n        else if (this.chips.length > 0) {\n            this._keyManager.setFirstItemActive();\n            this.stateChanges.next();\n        }\n        else {\n            this._focusInput();\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Attempt to focus an input if we have one.\n     * @return {?}\n     */\n    MatChipList.prototype._focusInput = function () {\n        if (this._chipInput) {\n            this._chipInput.focus();\n        }\n    };\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     * @param {?} event\n     * @return {?}\n     */\n    MatChipList.prototype._keydown = function (event) {\n        var /** @type {?} */ code = event.keyCode;\n        var /** @type {?} */ target = (event.target);\n        var /** @type {?} */ isInputEmpty = this._isInputEmpty(target);\n        var /** @type {?} */ isRtl = this._dir && this._dir.value == 'rtl';\n        var /** @type {?} */ isPrevKey = (code === (isRtl ? RIGHT_ARROW : LEFT_ARROW));\n        var /** @type {?} */ isNextKey = (code === (isRtl ? LEFT_ARROW : RIGHT_ARROW));\n        var /** @type {?} */ isBackKey = code === BACKSPACE;\n        // If they are on an empty input and hit backspace, focus the last chip\n        if (isInputEmpty && isBackKey) {\n            this._keyManager.setLastItemActive();\n            event.preventDefault();\n            return;\n        }\n        // If they are on a chip, check for space/left/right, otherwise pass to our key manager (like\n        // up/down keys)\n        if (target && target.classList.contains('mat-chip')) {\n            if (isPrevKey) {\n                this._keyManager.setPreviousItemActive();\n                event.preventDefault();\n            }\n            else if (isNextKey) {\n                this._keyManager.setNextItemActive();\n                event.preventDefault();\n            }\n            else {\n                this._keyManager.onKeydown(event);\n            }\n        }\n        this.stateChanges.next();\n    };\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     * @return {?}\n     */\n    MatChipList.prototype._updateTabIndex = function () {\n        // If we have 0 chips, we should not allow keyboard focus\n        this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n    };\n    /**\n     * Update key manager's active item when chip is deleted.\n     * If the deleted chip is the last chip in chip list, focus the new last chip.\n     * Otherwise focus the next chip in the list.\n     * Save `_lastDestroyedIndex` so we can set the correct focus.\n     * @param {?} chip\n     * @return {?}\n     */\n    MatChipList.prototype._updateKeyManager = function (chip) {\n        var /** @type {?} */ chipIndex = this.chips.toArray().indexOf(chip);\n        if (this._isValidIndex(chipIndex)) {\n            if (chip._hasFocus) {\n                // Check whether the chip is not the last item\n                if (chipIndex < this.chips.length - 1) {\n                    this._keyManager.setActiveItem(chipIndex);\n                }\n                else if (chipIndex - 1 >= 0) {\n                    this._keyManager.setActiveItem(chipIndex - 1);\n                }\n            }\n            if (this._keyManager.activeItemIndex === chipIndex) {\n                this._lastDestroyedIndex = chipIndex;\n            }\n        }\n    };\n    /**\n     * Checks to see if a focus chip was recently destroyed so that we can refocus the next closest\n     * one.\n     * @return {?}\n     */\n    MatChipList.prototype._updateFocusForDestroyedChips = function () {\n        var /** @type {?} */ chipsArray = this.chips;\n        if (this._lastDestroyedIndex != null && chipsArray.length > 0) {\n            // Check whether the destroyed chip was the last item\n            var /** @type {?} */ newFocusIndex = Math.min(this._lastDestroyedIndex, chipsArray.length - 1);\n            this._keyManager.setActiveItem(newFocusIndex);\n            var /** @type {?} */ focusChip = this._keyManager.activeItem;\n            // Focus the chip\n            if (focusChip) {\n                focusChip.focus();\n            }\n        }\n        // Reset our destroyed index\n        this._lastDestroyedIndex = null;\n    };\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param {?} index The index to be checked.\n     * @return {?} True if the index is valid for our list of chips.\n     */\n    MatChipList.prototype._isValidIndex = function (index) {\n        return index >= 0 && index < this.chips.length;\n    };\n    /**\n     * @param {?} element\n     * @return {?}\n     */\n    MatChipList.prototype._isInputEmpty = function (element) {\n        if (element && element.nodeName.toLowerCase() === 'input') {\n            var /** @type {?} */ input = (element);\n            return !input.value;\n        }\n        return false;\n    };\n    /**\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?}\n     */\n    MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {\n        var _this = this;\n        if (isUserInput === void 0) {\n            isUserInput = true;\n        }\n        this._clearSelection();\n        this.chips.forEach(function (chip) { return chip.deselect(); });\n        if (Array.isArray(value)) {\n            value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n            this._sortValues();\n        }\n        else {\n            var /** @type {?} */ correspondingChip = this._selectValue(value, isUserInput);\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what chip the user interacted with last.\n            if (correspondingChip) {\n                this._keyManager.setActiveItem(this.chips.toArray().indexOf(correspondingChip));\n            }\n        }\n    };\n    /**\n     * Finds and selects the chip based on its value.\n     * @param {?} value\n     * @param {?=} isUserInput\n     * @return {?} Chip that has the corresponding value.\n     */\n    MatChipList.prototype._selectValue = function (value, isUserInput) {\n        var _this = this;\n        if (isUserInput === void 0) {\n            isUserInput = true;\n        }\n        var /** @type {?} */ correspondingChip = this.chips.find(function (chip) {\n            return chip.value != null && _this._compareWith(chip.value, value);\n        });\n        if (correspondingChip) {\n            isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n            this._selectionModel.select(correspondingChip);\n        }\n        return correspondingChip;\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._initializeSelection = function () {\n        var _this = this;\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(function () {\n            if (_this.ngControl || _this._value) {\n                _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);\n                _this.stateChanges.next();\n            }\n        });\n    };\n    /**\n     * Deselects every chip in the list.\n     * @param {?=} skip Chip that should not be deselected.\n     * @return {?}\n     */\n    MatChipList.prototype._clearSelection = function (skip) {\n        this._selectionModel.clear();\n        this.chips.forEach(function (chip) {\n            if (chip !== skip) {\n                chip.deselect();\n            }\n        });\n        this.stateChanges.next();\n    };\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     * @return {?}\n     */\n    MatChipList.prototype._sortValues = function () {\n        var _this = this;\n        if (this._multiple) {\n            this._selectionModel.clear();\n            this.chips.forEach(function (chip) {\n                if (chip.selected) {\n                    _this._selectionModel.select(chip);\n                }\n            });\n            this.stateChanges.next();\n        }\n    };\n    /**\n     * Emits change event to set the model value.\n     * @param {?=} fallbackValue\n     * @return {?}\n     */\n    MatChipList.prototype._propagateChanges = function (fallbackValue) {\n        var /** @type {?} */ valueToEmit = null;\n        if (Array.isArray(this.selected)) {\n            valueToEmit = this.selected.map(function (chip) { return chip.value; });\n        }\n        else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.change.emit(new MatChipListChange(this, valueToEmit));\n        this.valueChange.emit(valueToEmit);\n        this._onChange(valueToEmit);\n        this._changeDetectorRef.markForCheck();\n    };\n    /**\n     * When blurred, mark the field as touched when focus moved outside the chip list.\n     * @return {?}\n     */\n    MatChipList.prototype._blur = function () {\n        var _this = this;\n        if (!this.disabled) {\n            if (this._chipInput) {\n                // If there's a chip input, we should check whether the focus moved to chip input.\n                // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                // to chip input, do nothing.\n                // Timeout is needed to wait for the focus() event trigger on chip input.\n                setTimeout(function () {\n                    if (!_this.focused) {\n                        _this._markAsTouched();\n                    }\n                });\n            }\n            else {\n                // If there's no chip input, then mark the field as touched.\n                this._markAsTouched();\n            }\n        }\n    };\n    /**\n     * Mark the field as touched\n     * @return {?}\n     */\n    MatChipList.prototype._markAsTouched = function () {\n        this._onTouched();\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._resetChips = function () {\n        this._dropSubscriptions();\n        this._listenToChipsFocus();\n        this._listenToChipsSelection();\n        this._listenToChipsRemoved();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._dropSubscriptions = function () {\n        if (this._chipFocusSubscription) {\n            this._chipFocusSubscription.unsubscribe();\n            this._chipFocusSubscription = null;\n        }\n        if (this._chipBlurSubscription) {\n            this._chipBlurSubscription.unsubscribe();\n            this._chipBlurSubscription = null;\n        }\n        if (this._chipSelectionSubscription) {\n            this._chipSelectionSubscription.unsubscribe();\n            this._chipSelectionSubscription = null;\n        }\n    };\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsSelection = function () {\n        var _this = this;\n        this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {\n            event.source.selected\n                ? _this._selectionModel.select(event.source)\n                : _this._selectionModel.deselect(event.source);\n            // For single selection chip list, make sure the deselected value is unselected.\n            if (!_this.multiple) {\n                _this.chips.forEach(function (chip) {\n                    if (!_this._selectionModel.isSelected(chip) && chip.selected) {\n                        chip.deselect();\n                    }\n                });\n            }\n            if (event.isUserInput) {\n                _this._propagateChanges();\n            }\n        });\n    };\n    /**\n     * Listens to user-generated selection events on each chip.\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsFocus = function () {\n        var _this = this;\n        this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {\n            var /** @type {?} */ chipIndex = _this.chips.toArray().indexOf(event.chip);\n            if (_this._isValidIndex(chipIndex)) {\n                _this._keyManager.updateActiveItemIndex(chipIndex);\n            }\n            _this.stateChanges.next();\n        });\n        this._chipBlurSubscription = this.chipBlurChanges.subscribe(function (_) {\n            _this._blur();\n            _this.stateChanges.next();\n        });\n    };\n    /**\n     * @return {?}\n     */\n    MatChipList.prototype._listenToChipsRemoved = function () {\n        var _this = this;\n        this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {\n            _this._updateKeyManager(event.chip);\n        });\n    };\n    return MatChipList;\n}());\n/**\n * Directive that adds chip-specific behaviors to an input element inside <mat-form-field>.\n * May be placed inside or outside of an <mat-chip-list>.\n */\nvar MatChipInput = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _elementRef\n     */\n    function MatChipInput(_elementRef) {\n        this._elementRef = _elementRef;\n        this.focused = false;\n        this._addOnBlur = false;\n        /**\n         * The list of key codes that will trigger a chipEnd event.\n         *\n         * Defaults to `[ENTER]`.\n         */\n        // TODO(tinayuangao): Support Set here\n        this.separatorKeyCodes = [ENTER];\n        /**\n         * Emitted when a chip is to be added.\n         */\n        this.chipEnd = new EventEmitter();\n        this.placeholder = '';\n        this._inputElement = this._elementRef.nativeElement;\n    }\n    Object.defineProperty(MatChipInput.prototype, \"chipList\", {\n        /**\n         * Register input for chip list\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) {\n            if (value) {\n                this._chipList = value;\n                this._chipList.registerInput(this);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipInput.prototype, \"addOnBlur\", {\n        /**\n         * Whether or not the chipEnd event will be emitted when the input is blurred.\n         * @return {?}\n         */\n        get: function () { return this._addOnBlur; },\n        /**\n         * @param {?} value\n         * @return {?}\n         */\n        set: function (value) { this._addOnBlur = coerceBooleanProperty(value); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MatChipInput.prototype, \"empty\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ value = this._inputElement.value;\n            return value == null || value === '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Utility method to make host definition/tests more clear.\n     * @param {?=} event\n     * @return {?}\n     */\n    MatChipInput.prototype._keydown = function (event) {\n        this._emitChipEnd(event);\n    };\n    /**\n     * Checks to see if the blur should emit the (chipEnd) event.\n     * @return {?}\n     */\n    MatChipInput.prototype._blur = function () {\n        if (this.addOnBlur) {\n            this._emitChipEnd();\n        }\n        this.focused = false;\n        // Blur the chip list if it is not focused\n        if (!this._chipList.focused) {\n            this._chipList._blur();\n        }\n        this._chipList.stateChanges.next();\n    };\n    /**\n     * @return {?}\n     */\n    MatChipInput.prototype._focus = function () {\n        this.focused = true;\n        this._chipList.stateChanges.next();\n    };\n    /**\n     * Checks to see if the (chipEnd) event needs to be emitted.\n     * @param {?=} event\n     * @return {?}\n     */\n    MatChipInput.prototype._emitChipEnd = function (event) {\n        if (!this._inputElement.value && !!event) {\n            this._chipList._keydown(event);\n        }\n        if (!event || this.separatorKeyCodes.indexOf(event.keyCode) > -1) {\n            this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n            if (event) {\n                event.preventDefault();\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    MatChipInput.prototype.focus = function () { this._inputElement.focus(); };\n    return MatChipInput;\n}());\nvar MatChipsModule = /*@__PURE__*/ (function () {\n    function MatChipsModule() {\n    }\n    return MatChipsModule;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { MatChipsModule, MatChipListChange, MatChipList, MatChipSelectionChange, MatChipBase, _MatChipMixinBase, MatBasicChip, MatChip, MatChipRemove, MatChipInput };\n//# sourceMappingURL=chips.es5.js.map\n",null]}